import "./chunk-X7HCJ7ZS.js";
import {
  $,
  A,
  B,
  Ct,
  D,
  EE,
  Et,
  F,
  G,
  I,
  J,
  Js,
  K,
  L,
  M,
  O,
  OE,
  Ot,
  P,
  Q,
  R,
  Rt2 as Rt,
  S,
  St,
  Tt,
  U,
  W,
  X,
  Y,
  Z,
  _,
  a,
  aE,
  at,
  b,
  bt,
  c,
  ct,
  dt2 as dt,
  e,
  eE,
  f,
  ft,
  g,
  gt,
  h,
  ht,
  it,
  j,
  k,
  l,
  lt,
  m,
  mt,
  n,
  nt,
  o,
  ot,
  p,
  pt,
  q,
  r,
  rE,
  rt,
  s,
  t,
  tt,
  uE,
  ut,
  v,
  vt,
  w,
  wt2 as wt,
  x,
  y,
  z
} from "./chunk-JDKLREQO.js";
import "./chunk-DYWWDCTU.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  afterUpdate,
  assign,
  bind,
  binding_callbacks,
  bubble,
  children,
  claim_component,
  claim_element,
  compute_rest_props,
  createEventDispatcher,
  create_component,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  get_spread_object,
  get_spread_update,
  globals,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  safe_not_equal,
  set_attributes,
  transition_in,
  transition_out,
  validate_slots
} from "./chunk-CVLNV7PT.js";
import "./chunk-672HPU4M.js";
import "./chunk-EQCVQC35.js";

// node_modules/@carbon/charts-svelte/dist/BaseChart.svelte
var { console: console_1 } = globals;
var file = "node_modules/@carbon/charts-svelte/dist/BaseChart.svelte";
function create_fragment(ctx) {
  let div;
  let div_levels = [
    { id: (
      /*id*/
      ctx[1]
    ) },
    { class: chartHolderCssClass },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { id: true, class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 40, 0, 1365);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[7](div);
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*id*/
        2 && { id: (
          /*id*/
          ctx2[1]
        ) },
        { class: chartHolderCssClass },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx2[2]
      ]));
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[7](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var chartHolderCssClass = "cds--chart-holder";
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["data", "options", "Chart", "chart", "ref", "id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BaseChart", slots, []);
  let { data = [] } = $$props;
  let { options = {} } = $$props;
  let { Chart } = $$props;
  let { chart } = $$props;
  let { ref } = $$props;
  let { id = `chart-${Math.random().toString(36)}` } = $$props;
  const dispatch = createEventDispatcher();
  onMount(() => {
    try {
      $$invalidate(3, chart = new Chart(ref, { data, options }));
      dispatch("load");
    } catch (error) {
      console.error("Failed to initialize chart:", error);
    }
  });
  afterUpdate(() => {
    if (chart) {
      try {
        chart.model.setData(data);
        chart.model.setOptions(options);
        dispatch("update", { data, options });
      } catch (error) {
        console.error("Failed to update chart:", error);
      }
    }
  });
  onDestroy(() => {
    if (chart) {
      dispatch("destroy");
      chart.components.forEach((component) => component.destroy());
      chart.model.set({ destroyed: true }, { skipUpdate: true });
      $$invalidate(3, chart = void 0);
    }
  });
  $$self.$$.on_mount.push(function() {
    if (Chart === void 0 && !("Chart" in $$props || $$self.$$.bound[$$self.$$.props["Chart"]])) {
      console_1.warn("<BaseChart> was created without expected prop 'Chart'");
    }
    if (chart === void 0 && !("chart" in $$props || $$self.$$.bound[$$self.$$.props["chart"]])) {
      console_1.warn("<BaseChart> was created without expected prop 'chart'");
    }
    if (ref === void 0 && !("ref" in $$props || $$self.$$.bound[$$self.$$.props["ref"]])) {
      console_1.warn("<BaseChart> was created without expected prop 'ref'");
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref = $$value;
      $$invalidate(0, ref);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("data" in $$new_props) $$invalidate(4, data = $$new_props.data);
    if ("options" in $$new_props) $$invalidate(5, options = $$new_props.options);
    if ("Chart" in $$new_props) $$invalidate(6, Chart = $$new_props.Chart);
    if ("chart" in $$new_props) $$invalidate(3, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
  };
  $$self.$capture_state = () => ({
    onMount,
    afterUpdate,
    onDestroy,
    createEventDispatcher,
    chartHolderCssClass,
    data,
    options,
    Chart,
    chart,
    ref,
    id,
    dispatch
  });
  $$self.$inject_state = ($$new_props) => {
    if ("data" in $$props) $$invalidate(4, data = $$new_props.data);
    if ("options" in $$props) $$invalidate(5, options = $$new_props.options);
    if ("Chart" in $$props) $$invalidate(6, Chart = $$new_props.Chart);
    if ("chart" in $$props) $$invalidate(3, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ref, id, $$restProps, chart, data, options, Chart, div_binding];
}
var BaseChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      data: 4,
      options: 5,
      Chart: 6,
      chart: 3,
      ref: 0,
      id: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BaseChart",
      options,
      id: create_fragment.name
    });
  }
  get data() {
    throw new Error("<BaseChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BaseChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<BaseChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<BaseChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Chart() {
    throw new Error("<BaseChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Chart(value) {
    throw new Error("<BaseChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<BaseChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<BaseChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<BaseChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<BaseChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<BaseChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<BaseChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BaseChart_default = BaseChart;

// node_modules/@carbon/charts-svelte/dist/AlluvialChart.svelte
function create_fragment2(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: tt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AlluvialChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<AlluvialChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<AlluvialChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    AlluvialChartCore: tt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var AlluvialChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlluvialChart",
      options,
      id: create_fragment2.name
    });
  }
  get options() {
    throw new Error("<AlluvialChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<AlluvialChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<AlluvialChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<AlluvialChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<AlluvialChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<AlluvialChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<AlluvialChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<AlluvialChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AlluvialChart_default = AlluvialChart;

// node_modules/@carbon/charts-svelte/dist/AreaChart.svelte
function create_fragment3(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: ot },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AreaChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<AreaChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<AreaChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    AreaChartCore: ot,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var AreaChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AreaChart",
      options,
      id: create_fragment3.name
    });
  }
  get options() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<AreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<AreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AreaChart_default = AreaChart;

// node_modules/@carbon/charts-svelte/dist/BarChartGrouped.svelte
function create_fragment4(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: pt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarChartGrouped", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<BarChartGrouped> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BarChartGrouped> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    GroupedBarChartCore: pt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var BarChartGrouped = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarChartGrouped",
      options,
      id: create_fragment4.name
    });
  }
  get options() {
    throw new Error("<BarChartGrouped>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<BarChartGrouped>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<BarChartGrouped>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BarChartGrouped>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<BarChartGrouped>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<BarChartGrouped>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<BarChartGrouped>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<BarChartGrouped>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BarChartGrouped_default = BarChartGrouped;

// node_modules/@carbon/charts-svelte/dist/BarChartSimple.svelte
function create_fragment5(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: bt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarChartSimple", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<BarChartSimple> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BarChartSimple> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    SimpleBarChartCore: bt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var BarChartSimple = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarChartSimple",
      options,
      id: create_fragment5.name
    });
  }
  get options() {
    throw new Error("<BarChartSimple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<BarChartSimple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<BarChartSimple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BarChartSimple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<BarChartSimple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<BarChartSimple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<BarChartSimple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<BarChartSimple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BarChartSimple_default = BarChartSimple;

// node_modules/@carbon/charts-svelte/dist/BarChartStacked.svelte
function create_fragment6(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: St },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarChartStacked", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<BarChartStacked> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BarChartStacked> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    StackedBarChartCore: St,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var BarChartStacked = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarChartStacked",
      options,
      id: create_fragment6.name
    });
  }
  get options() {
    throw new Error("<BarChartStacked>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<BarChartStacked>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<BarChartStacked>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BarChartStacked>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<BarChartStacked>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<BarChartStacked>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<BarChartStacked>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<BarChartStacked>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BarChartStacked_default = BarChartStacked;

// node_modules/@carbon/charts-svelte/dist/BoxplotChart.svelte
function create_fragment7(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: nt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BoxplotChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<BoxplotChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BoxplotChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    BoxplotChartCore: nt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var BoxplotChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BoxplotChart",
      options,
      id: create_fragment7.name
    });
  }
  get options() {
    throw new Error("<BoxplotChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<BoxplotChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<BoxplotChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BoxplotChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<BoxplotChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<BoxplotChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<BoxplotChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<BoxplotChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BoxplotChart_default = BoxplotChart;

// node_modules/@carbon/charts-svelte/dist/BubbleChart.svelte
function create_fragment8(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: it },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BubbleChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<BubbleChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BubbleChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    BubbleChartCore: it,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var BubbleChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BubbleChart",
      options,
      id: create_fragment8.name
    });
  }
  get options() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<BubbleChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<BubbleChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BubbleChart_default = BubbleChart;

// node_modules/@carbon/charts-svelte/dist/BulletChart.svelte
function create_fragment9(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: rt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BulletChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<BulletChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BulletChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    BulletChartCore: rt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var BulletChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BulletChart",
      options,
      id: create_fragment9.name
    });
  }
  get options() {
    throw new Error("<BulletChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<BulletChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<BulletChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BulletChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<BulletChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<BulletChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<BulletChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<BulletChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BulletChart_default = BulletChart;

// node_modules/@carbon/charts-svelte/dist/ChoroplethChart.svelte
function create_fragment10(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: at },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ChoroplethChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<ChoroplethChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ChoroplethChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    ChoroplethChartCore: at,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var ChoroplethChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChoroplethChart",
      options,
      id: create_fragment10.name
    });
  }
  get options() {
    throw new Error("<ChoroplethChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<ChoroplethChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<ChoroplethChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ChoroplethChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<ChoroplethChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<ChoroplethChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ChoroplethChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ChoroplethChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ChoroplethChart_default = ChoroplethChart;

// node_modules/@carbon/charts-svelte/dist/CirclePackChart.svelte
function create_fragment11(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: ht },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CirclePackChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<CirclePackChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<CirclePackChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    CirclePackChartCore: ht,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var CirclePackChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CirclePackChart",
      options,
      id: create_fragment11.name
    });
  }
  get options() {
    throw new Error("<CirclePackChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<CirclePackChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<CirclePackChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<CirclePackChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<CirclePackChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<CirclePackChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<CirclePackChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<CirclePackChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CirclePackChart_default = CirclePackChart;

// node_modules/@carbon/charts-svelte/dist/ComboChart.svelte
function create_fragment12(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: ct },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComboChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<ComboChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ComboChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    ComboChartCore: ct,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var ComboChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComboChart",
      options,
      id: create_fragment12.name
    });
  }
  get options() {
    throw new Error("<ComboChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<ComboChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<ComboChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ComboChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<ComboChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<ComboChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ComboChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ComboChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComboChart_default = ComboChart;

// node_modules/@carbon/charts-svelte/dist/DonutChart.svelte
function create_fragment13(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: mt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DonutChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<DonutChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<DonutChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    DonutChartCore: mt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var DonutChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DonutChart",
      options,
      id: create_fragment13.name
    });
  }
  get options() {
    throw new Error("<DonutChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<DonutChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<DonutChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<DonutChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<DonutChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<DonutChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<DonutChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<DonutChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DonutChart_default = DonutChart;

// node_modules/@carbon/charts-svelte/dist/GaugeChart.svelte
function create_fragment14(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: lt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GaugeChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<GaugeChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<GaugeChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    GaugeChartCore: lt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var GaugeChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GaugeChart",
      options,
      id: create_fragment14.name
    });
  }
  get options() {
    throw new Error("<GaugeChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<GaugeChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<GaugeChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<GaugeChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<GaugeChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<GaugeChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<GaugeChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<GaugeChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GaugeChart_default = GaugeChart;

// node_modules/@carbon/charts-svelte/dist/HeatmapChart.svelte
function create_fragment15(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: dt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HeatmapChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<HeatmapChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<HeatmapChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    HeatmapChartCore: dt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var HeatmapChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HeatmapChart",
      options,
      id: create_fragment15.name
    });
  }
  get options() {
    throw new Error("<HeatmapChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<HeatmapChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<HeatmapChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<HeatmapChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<HeatmapChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<HeatmapChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HeatmapChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HeatmapChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HeatmapChart_default = HeatmapChart;

// node_modules/@carbon/charts-svelte/dist/HistogramChart.svelte
function create_fragment16(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: Ct },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HistogramChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<HistogramChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<HistogramChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    HistogramChartCore: Ct,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var HistogramChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HistogramChart",
      options,
      id: create_fragment16.name
    });
  }
  get options() {
    throw new Error("<HistogramChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<HistogramChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<HistogramChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<HistogramChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<HistogramChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<HistogramChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<HistogramChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<HistogramChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HistogramChart_default = HistogramChart;

// node_modules/@carbon/charts-svelte/dist/LineChart.svelte
function create_fragment17(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: ut },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<LineChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<LineChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    LineChartCore: ut,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var LineChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineChart",
      options,
      id: create_fragment17.name
    });
  }
  get options() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<LineChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<LineChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineChart_default = LineChart;

// node_modules/@carbon/charts-svelte/dist/LollipopChart.svelte
function create_fragment18(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: vt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LollipopChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<LollipopChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<LollipopChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    LollipopChartCore: vt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var LollipopChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LollipopChart",
      options,
      id: create_fragment18.name
    });
  }
  get options() {
    throw new Error("<LollipopChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<LollipopChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<LollipopChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<LollipopChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<LollipopChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<LollipopChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<LollipopChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<LollipopChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LollipopChart_default = LollipopChart;

// node_modules/@carbon/charts-svelte/dist/MeterChart.svelte
function create_fragment19(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: gt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MeterChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<MeterChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<MeterChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    MeterChartCore: gt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var MeterChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MeterChart",
      options,
      id: create_fragment19.name
    });
  }
  get options() {
    throw new Error("<MeterChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<MeterChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<MeterChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<MeterChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<MeterChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<MeterChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<MeterChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<MeterChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MeterChart_default = MeterChart;

// node_modules/@carbon/charts-svelte/dist/PieChart.svelte
function create_fragment20(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: Js },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PieChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<PieChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<PieChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    PieChartCore: Js,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var PieChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PieChart",
      options,
      id: create_fragment20.name
    });
  }
  get options() {
    throw new Error("<PieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<PieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<PieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<PieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<PieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<PieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<PieChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<PieChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PieChart_default = PieChart;

// node_modules/@carbon/charts-svelte/dist/RadarChart.svelte
function create_fragment21(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: wt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadarChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<RadarChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<RadarChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    RadarChartCore: wt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var RadarChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadarChart",
      options,
      id: create_fragment21.name
    });
  }
  get options() {
    throw new Error("<RadarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<RadarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<RadarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<RadarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<RadarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<RadarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<RadarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<RadarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadarChart_default = RadarChart;

// node_modules/@carbon/charts-svelte/dist/ScatterChart.svelte
function create_fragment22(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: Et },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScatterChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<ScatterChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ScatterChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    ScatterChartCore: Et,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var ScatterChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScatterChart",
      options,
      id: create_fragment22.name
    });
  }
  get options() {
    throw new Error("<ScatterChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<ScatterChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<ScatterChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ScatterChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<ScatterChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<ScatterChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<ScatterChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<ScatterChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScatterChart_default = ScatterChart;

// node_modules/@carbon/charts-svelte/dist/StackedAreaChart.svelte
function create_fragment23(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: Ot },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StackedAreaChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<StackedAreaChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<StackedAreaChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    StackedAreaChartCore: Ot,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var StackedAreaChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StackedAreaChart",
      options,
      id: create_fragment23.name
    });
  }
  get options() {
    throw new Error("<StackedAreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<StackedAreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<StackedAreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<StackedAreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<StackedAreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<StackedAreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<StackedAreaChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<StackedAreaChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StackedAreaChart_default = StackedAreaChart;

// node_modules/@carbon/charts-svelte/dist/TreeChart.svelte
function create_fragment24(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: Rt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<TreeChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<TreeChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    TreeChartCore: Rt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var TreeChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeChart",
      options,
      id: create_fragment24.name
    });
  }
  get options() {
    throw new Error("<TreeChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<TreeChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<TreeChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<TreeChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<TreeChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<TreeChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TreeChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TreeChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeChart_default = TreeChart;

// node_modules/@carbon/charts-svelte/dist/TreemapChart.svelte
function create_fragment25(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: Tt },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreemapChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<TreemapChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<TreemapChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    TreemapChartCore: Tt,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var TreemapChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreemapChart",
      options,
      id: create_fragment25.name
    });
  }
  get options() {
    throw new Error("<TreemapChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<TreemapChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<TreemapChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<TreemapChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<TreemapChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<TreemapChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<TreemapChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<TreemapChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreemapChart_default = TreemapChart;

// node_modules/@carbon/charts-svelte/dist/WordCloudChart.svelte
function create_fragment26(ctx) {
  let basechart;
  let updating_ref;
  let updating_chart;
  let current;
  const basechart_spread_levels = [
    /*$$restProps*/
    ctx[4],
    { Chart: ft },
    { options: (
      /*options*/
      ctx[2]
    ) },
    { data: (
      /*data*/
      ctx[3]
    ) }
  ];
  function basechart_ref_binding(value) {
    ctx[5](value);
  }
  function basechart_chart_binding(value) {
    ctx[6](value);
  }
  let basechart_props = {};
  for (let i = 0; i < basechart_spread_levels.length; i += 1) {
    basechart_props = assign(basechart_props, basechart_spread_levels[i]);
  }
  if (
    /*ref*/
    ctx[1] !== void 0
  ) {
    basechart_props.ref = /*ref*/
    ctx[1];
  }
  if (
    /*chart*/
    ctx[0] !== void 0
  ) {
    basechart_props.chart = /*chart*/
    ctx[0];
  }
  basechart = new BaseChart_default({ props: basechart_props, $$inline: true });
  binding_callbacks.push(() => bind(basechart, "ref", basechart_ref_binding));
  binding_callbacks.push(() => bind(basechart, "chart", basechart_chart_binding));
  basechart.$on(
    "load",
    /*load_handler*/
    ctx[7]
  );
  basechart.$on(
    "update",
    /*update_handler*/
    ctx[8]
  );
  basechart.$on(
    "destroy",
    /*destroy_handler*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(basechart.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(basechart.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(basechart, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const basechart_changes = dirty & /*$$restProps, options, data*/
      28 ? get_spread_update(basechart_spread_levels, [
        dirty & /*$$restProps*/
        16 && get_spread_object(
          /*$$restProps*/
          ctx2[4]
        ),
        basechart_spread_levels[1],
        dirty & /*options*/
        4 && { options: (
          /*options*/
          ctx2[2]
        ) },
        dirty & /*data*/
        8 && { data: (
          /*data*/
          ctx2[3]
        ) }
      ]) : {};
      if (!updating_ref && dirty & /*ref*/
      2) {
        updating_ref = true;
        basechart_changes.ref = /*ref*/
        ctx2[1];
        add_flush_callback(() => updating_ref = false);
      }
      if (!updating_chart && dirty & /*chart*/
      1) {
        updating_chart = true;
        basechart_changes.chart = /*chart*/
        ctx2[0];
        add_flush_callback(() => updating_chart = false);
      }
      basechart.$set(basechart_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(basechart.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(basechart.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(basechart, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  const omit_props_names = ["options", "data", "chart", "ref"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("WordCloudChart", slots, []);
  let { options } = $$props;
  let { data } = $$props;
  let { chart = void 0 } = $$props;
  let { ref = void 0 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<WordCloudChart> was created without expected prop 'options'");
    }
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<WordCloudChart> was created without expected prop 'data'");
    }
  });
  function basechart_ref_binding(value) {
    ref = value;
    $$invalidate(1, ref);
  }
  function basechart_chart_binding(value) {
    chart = value;
    $$invalidate(0, chart);
  }
  function load_handler(event) {
    bubble.call(this, $$self, event);
  }
  function update_handler(event) {
    bubble.call(this, $$self, event);
  }
  function destroy_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("options" in $$new_props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$new_props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$new_props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
  };
  $$self.$capture_state = () => ({
    WordCloudChartCore: ft,
    BaseChart: BaseChart_default,
    options,
    data,
    chart,
    ref
  });
  $$self.$inject_state = ($$new_props) => {
    if ("options" in $$props) $$invalidate(2, options = $$new_props.options);
    if ("data" in $$props) $$invalidate(3, data = $$new_props.data);
    if ("chart" in $$props) $$invalidate(0, chart = $$new_props.chart);
    if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    chart,
    ref,
    options,
    data,
    $$restProps,
    basechart_ref_binding,
    basechart_chart_binding,
    load_handler,
    update_handler,
    destroy_handler
  ];
}
var WordCloudChart = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { options: 2, data: 3, chart: 0, ref: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WordCloudChart",
      options,
      id: create_fragment26.name
    });
  }
  get options() {
    throw new Error("<WordCloudChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<WordCloudChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<WordCloudChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<WordCloudChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chart() {
    throw new Error("<WordCloudChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chart(value) {
    throw new Error("<WordCloudChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ref() {
    throw new Error("<WordCloudChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ref(value) {
    throw new Error("<WordCloudChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var WordCloudChart_default = WordCloudChart;
export {
  k as Alignments,
  AlluvialChart_default as AlluvialChart,
  AreaChart_default as AreaChart,
  R as AreaEvent,
  Y as ArrowDirections,
  t as AxisEvent,
  uE as AxisFlavor,
  b as AxisPositions,
  EE as AxisTitleOrientations,
  BarChartGrouped_default as BarChartGrouped,
  BarChartSimple_default as BarChartSimple,
  BarChartStacked_default as BarChartStacked,
  S as BarEvent,
  BoxplotChart_default as BoxplotChart,
  v as BoxplotEvent,
  BubbleChart_default as BubbleChart,
  BulletChart_default as BulletChart,
  B as CalloutDirections,
  _ as CanvasZoomEvent,
  w as CartesianOrientations,
  r as ChartEvent,
  g as ChartTheme,
  p as ChartTypes,
  ChoroplethChart_default as ChoroplethChart,
  CirclePackChart_default as CirclePackChart,
  h as ColorClassNameTypes,
  OE as ColorLegendType,
  ComboChart_default as ComboChart,
  eE as DividerStatus,
  J as DominantBaseline,
  DonutChart_default as DonutChart,
  ChoroplethChart_default as ExperimentalChoroplethChart,
  GaugeChart_default as GaugeChart,
  U as GaugeEvent,
  Q as GaugeTypes,
  HeatmapChart_default as HeatmapChart,
  HistogramChart_default as HistogramChart,
  q as LayoutAlignItems,
  W as LayoutDirection,
  z as LayoutGrowth,
  rE as LegendItemType,
  G as LegendOrientations,
  P as LegendPositions,
  LineChart_default as LineChart,
  l as LineEvent,
  LollipopChart_default as LollipopChart,
  MeterChart_default as MeterChart,
  O as ModalEvent,
  e as ModelEvent,
  PieChart_default as PieChart,
  M as PieEvent,
  aE as Projection,
  RadarChart_default as RadarChart,
  c as RadarEvent,
  D as RenderTypes,
  F as ScaleTypes,
  ScatterChart_default as ScatterChart,
  I as ScatterEvent,
  Z as Skeletons,
  StackedAreaChart_default as StackedAreaChart,
  $ as Statuses,
  x as TextAnchor,
  A as ThresholdEvent,
  j as TickRotations,
  y as ToolbarControlTypes,
  n as TooltipEvent,
  TreeChart_default as TreeChart,
  L as TreeEvent,
  X as TreeTypes,
  TreemapChart_default as TreemapChart,
  m as TreemapEvent,
  K as TruncationTypes,
  WordCloudChart_default as WordCloudChart,
  s as WordCloudEvent,
  f as ZoomBarTypes,
  o as ZoomDomainEvent,
  a as ZoombarEvent
};
//# sourceMappingURL=@carbon_charts-svelte.js.map
