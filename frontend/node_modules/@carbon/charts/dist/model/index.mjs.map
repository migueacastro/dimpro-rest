{"version":3,"file":"index.mjs","sources":["../../../../node_modules/lodash-es/_arrayAggregator.js","../../../../node_modules/lodash-es/_baseAggregator.js","../../../../node_modules/lodash-es/_createAggregator.js","../../../../node_modules/lodash-es/fromPairs.js","../../../../node_modules/lodash-es/groupBy.js","../../../../node_modules/d3-array/src/count.js","../../../../node_modules/d3-array/src/identity.js","../../../../node_modules/d3-array/src/sort.js","../../../../node_modules/d3-array/src/array.js","../../../../node_modules/d3-array/src/constant.js","../../../../node_modules/d3-array/src/nice.js","../../../../node_modules/d3-array/src/threshold/sturges.js","../../../../node_modules/d3-array/src/bin.js","../../../../node_modules/d3-array/src/quickselect.js","../../../../node_modules/d3-array/src/quantile.js","../../../../node_modules/d3/node_modules/d3-shape/src/offset/none.js","../../../../node_modules/d3/node_modules/d3-shape/src/order/none.js","../../../../node_modules/d3/node_modules/d3-shape/src/stack.js","../../../../node_modules/d3/node_modules/d3-shape/src/offset/diverging.js","../../src/model/model.ts","../../src/model/cartesian-charts.ts","../../src/model/alluvial.ts","../../src/model/boxplot.ts","../../src/model/bullet.ts","../../src/model/choropleth.ts","../../src/model/circle-pack.ts","../../src/model/pie.ts","../../src/model/gauge.ts","../../src/model/heatmap.ts","../../src/model/binned-charts.ts","../../src/model/meter.ts","../../src/model/radar.ts","../../src/model/tree.ts","../../src/model/treemap.ts","../../src/model/wordcloud.ts"],"sourcesContent":["/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nexport default arrayAggregator;\n","import baseEach from './_baseEach.js';\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nexport default baseAggregator;\n","import arrayAggregator from './_arrayAggregator.js';\nimport baseAggregator from './_baseAggregator.js';\nimport baseIteratee from './_baseIteratee.js';\nimport isArray from './isArray.js';\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nexport default createAggregator;\n","/**\n * The inverse of `_.toPairs`; this method returns an object composed\n * from key-value `pairs`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} pairs The key-value pairs.\n * @returns {Object} Returns the new object.\n * @example\n *\n * _.fromPairs([['a', 1], ['b', 2]]);\n * // => { 'a': 1, 'b': 2 }\n */\nfunction fromPairs(pairs) {\n  var index = -1,\n      length = pairs == null ? 0 : pairs.length,\n      result = {};\n\n  while (++index < length) {\n    var pair = pairs[index];\n    result[pair[0]] = pair[1];\n  }\n  return result;\n}\n\nexport default fromPairs;\n","import baseAssignValue from './_baseAssignValue.js';\nimport createAggregator from './_createAggregator.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { '4': [4.2], '6': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy(['one', 'two', 'three'], 'length');\n * // => { '3': ['one', 'two'], '5': ['three'] }\n */\nvar groupBy = createAggregator(function(result, value, key) {\n  if (hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    baseAssignValue(result, key, [value]);\n  }\n});\n\nexport default groupBy;\n","export default function count(values, valueof) {\n  let count = 0;\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value != null && (value = +value) >= value) {\n        ++count;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {\n        ++count;\n      }\n    }\n  }\n  return count;\n}\n","export default function identity(x) {\n  return x;\n}\n","import ascending from \"./ascending.js\";\nimport permute from \"./permute.js\";\n\nexport default function sort(values, ...F) {\n  if (typeof values[Symbol.iterator] !== \"function\") throw new TypeError(\"values is not iterable\");\n  values = Array.from(values);\n  let [f] = F;\n  if ((f && f.length !== 2) || F.length > 1) {\n    const index = Uint32Array.from(values, (d, i) => i);\n    if (F.length > 1) {\n      F = F.map(f => values.map(f));\n      index.sort((i, j) => {\n        for (const f of F) {\n          const c = ascendingDefined(f[i], f[j]);\n          if (c) return c;\n        }\n      });\n    } else {\n      f = values.map(f);\n      index.sort((i, j) => ascendingDefined(f[i], f[j]));\n    }\n    return permute(values, index);\n  }\n  return values.sort(compareDefined(f));\n}\n\nexport function compareDefined(compare = ascending) {\n  if (compare === ascending) return ascendingDefined;\n  if (typeof compare !== \"function\") throw new TypeError(\"compare is not a function\");\n  return (a, b) => {\n    const x = compare(a, b);\n    if (x || x === 0) return x;\n    return (compare(b, b) === 0) - (compare(a, a) === 0);\n  };\n}\n\nexport function ascendingDefined(a, b) {\n  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);\n}\n","var array = Array.prototype;\n\nexport var slice = array.slice;\nexport var map = array.map;\n","export default function constant(x) {\n  return () => x;\n}\n","import {tickIncrement} from \"./ticks.js\";\n\nexport default function nice(start, stop, count) {\n  let prestep;\n  while (true) {\n    const step = tickIncrement(start, stop, count);\n    if (step === prestep || step === 0 || !isFinite(step)) {\n      return [start, stop];\n    } else if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n    }\n    prestep = step;\n  }\n}\n","import count from \"../count.js\";\n\nexport default function thresholdSturges(values) {\n  return Math.max(1, Math.ceil(Math.log(count(values)) / Math.LN2) + 1);\n}\n","import {slice} from \"./array.js\";\nimport bisect from \"./bisect.js\";\nimport constant from \"./constant.js\";\nimport extent from \"./extent.js\";\nimport identity from \"./identity.js\";\nimport nice from \"./nice.js\";\nimport ticks, {tickIncrement} from \"./ticks.js\";\nimport sturges from \"./threshold/sturges.js\";\n\nexport default function bin() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    if (!Array.isArray(data)) data = Array.from(data);\n\n    var i,\n        n = data.length,\n        x,\n        step,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds, and nice the\n    // default domain accordingly.\n    if (!Array.isArray(tz)) {\n      const max = x1, tn = +tz;\n      if (domain === extent) [x0, x1] = nice(x0, x1, tn);\n      tz = ticks(x0, x1, tn);\n\n      // If the domain is aligned with the first tick (which it will by\n      // default), then we can use quantization rather than bisection to bin\n      // values, which is substantially faster.\n      if (tz[0] <= x0) step = tickIncrement(x0, x1, tn);\n\n      // If the last threshold is coincident with the domain’s upper bound, the\n      // last bin will be zero-width. If the default domain is used, and this\n      // last threshold is coincident with the maximum input value, we can\n      // extend the niced upper bound by one tick to ensure uniform bin widths;\n      // otherwise, we simply remove the last threshold. Note that we don’t\n      // coerce values or the domain to numbers, and thus must be careful to\n      // compare order (>=) rather than strict equality (===)!\n      if (tz[tz.length - 1] >= x1) {\n        if (max >= x1 && domain === extent) {\n          const step = tickIncrement(x0, x1, tn);\n          if (isFinite(step)) {\n            if (step > 0) {\n              x1 = (Math.floor(x1 / step) + 1) * step;\n            } else if (step < 0) {\n              x1 = (Math.ceil(x1 * -step) + 1) / -step;\n            }\n          }\n        } else {\n          tz.pop();\n        }\n      }\n    }\n\n    // Remove any thresholds outside the domain.\n    // Be careful not to mutate an array owned by the user!\n    var m = tz.length, a = 0, b = m;\n    while (tz[a] <= x0) ++a;\n    while (tz[b - 1] > x1) --b;\n    if (a || b < m) tz = tz.slice(a, b), m = b - a;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    if (isFinite(step)) {\n      if (step > 0) {\n        for (i = 0; i < n; ++i) {\n          if ((x = values[i]) != null && x0 <= x && x <= x1) {\n            bins[Math.min(m, Math.floor((x - x0) / step))].push(data[i]);\n          }\n        }\n      } else if (step < 0) {\n        for (i = 0; i < n; ++i) {\n          if ((x = values[i]) != null && x0 <= x && x <= x1) {\n            const j = Math.floor((x0 - x) * step);\n            bins[Math.min(m, j + (tz[j] <= x))].push(data[i]); // handle off-by-one due to rounding\n          }\n        }\n      }\n    } else {\n      for (i = 0; i < n; ++i) {\n        if ((x = values[i]) != null && x0 <= x && x <= x1) {\n          bins[bisect(tz, x, 0, m)].push(data[i]);\n        }\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : constant(Array.isArray(_) ? slice.call(_) : _), histogram) : threshold;\n  };\n\n  return histogram;\n}\n","import {ascendingDefined, compareDefined} from \"./sort.js\";\n\n// Based on https://github.com/mourner/quickselect\n// ISC license, Copyright 2018 Vladimir Agafonkin.\nexport default function quickselect(array, k, left = 0, right = Infinity, compare) {\n  k = Math.floor(k);\n  left = Math.floor(Math.max(0, left));\n  right = Math.floor(Math.min(array.length - 1, right));\n\n  if (!(left <= k && k <= right)) return array;\n\n  compare = compare === undefined ? ascendingDefined : compareDefined(compare);\n\n  while (right > left) {\n    if (right - left > 600) {\n      const n = right - left + 1;\n      const m = k - left + 1;\n      const z = Math.log(n);\n      const s = 0.5 * Math.exp(2 * z / 3);\n      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n      quickselect(array, k, newLeft, newRight, compare);\n    }\n\n    const t = array[k];\n    let i = left;\n    let j = right;\n\n    swap(array, left, k);\n    if (compare(array[right], t) > 0) swap(array, left, right);\n\n    while (i < j) {\n      swap(array, i, j), ++i, --j;\n      while (compare(array[i], t) < 0) ++i;\n      while (compare(array[j], t) > 0) --j;\n    }\n\n    if (compare(array[left], t) === 0) swap(array, left, j);\n    else ++j, swap(array, j, right);\n\n    if (j <= k) left = j + 1;\n    if (k <= j) right = j - 1;\n  }\n\n  return array;\n}\n\nfunction swap(array, i, j) {\n  const t = array[i];\n  array[i] = array[j];\n  array[j] = t;\n}\n","import max from \"./max.js\";\nimport maxIndex from \"./maxIndex.js\";\nimport min from \"./min.js\";\nimport minIndex from \"./minIndex.js\";\nimport quickselect from \"./quickselect.js\";\nimport number, {numbers} from \"./number.js\";\nimport {ascendingDefined} from \"./sort.js\";\nimport greatest from \"./greatest.js\";\n\nexport default function quantile(values, p, valueof) {\n  values = Float64Array.from(numbers(values, valueof));\n  if (!(n = values.length) || isNaN(p = +p)) return;\n  if (p <= 0 || n < 2) return min(values);\n  if (p >= 1) return max(values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),\n      value1 = min(values.subarray(i0 + 1));\n  return value0 + (value1 - value0) * (i - i0);\n}\n\nexport function quantileSorted(values, p, valueof = number) {\n  if (!(n = values.length) || isNaN(p = +p)) return;\n  if (p <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n}\n\nexport function quantileIndex(values, p, valueof = number) {\n  if (isNaN(p = +p)) return;\n  numbers = Float64Array.from(values, (_, i) => number(valueof(values[i], i, values)));\n  if (p <= 0) return minIndex(numbers);\n  if (p >= 1) return maxIndex(numbers);\n  var numbers,\n      index = Uint32Array.from(values, (_, i) => i),\n      j = numbers.length - 1,\n      i = Math.floor(j * p);\n  quickselect(index, i, 0, j, (i, j) => ascendingDefined(numbers[i], numbers[j]));\n  i = greatest(index.subarray(0, i + 1), (i) => numbers[i]);\n  return i >= 0 ? i : -1;\n}\n","export default function(series, order) {\n  if (!((n = series.length) > 1)) return;\n  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {\n    s0 = s1, s1 = series[order[i]];\n    for (j = 0; j < m; ++j) {\n      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n    }\n  }\n}\n","export default function(series) {\n  var n = series.length, o = new Array(n);\n  while (--n >= 0) o[n] = n;\n  return o;\n}\n","import array from \"./array.js\";\nimport constant from \"./constant.js\";\nimport offsetNone from \"./offset/none.js\";\nimport orderNone from \"./order/none.js\";\n\nfunction stackValue(d, key) {\n  return d[key];\n}\n\nfunction stackSeries(key) {\n  const series = [];\n  series.key = key;\n  return series;\n}\n\nexport default function() {\n  var keys = constant([]),\n      order = orderNone,\n      offset = offsetNone,\n      value = stackValue;\n\n  function stack(data) {\n    var sz = Array.from(keys.apply(this, arguments), stackSeries),\n        i, n = sz.length, j = -1,\n        oz;\n\n    for (const d of data) {\n      for (i = 0, ++j; i < n; ++i) {\n        (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;\n      }\n    }\n\n    for (i = 0, oz = array(order(sz)); i < n; ++i) {\n      sz[oz[i]].index = i;\n    }\n\n    offset(sz, oz);\n    return sz;\n  }\n\n  stack.keys = function(_) {\n    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant(Array.from(_)), stack) : keys;\n  };\n\n  stack.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), stack) : value;\n  };\n\n  stack.order = function(_) {\n    return arguments.length ? (order = _ == null ? orderNone : typeof _ === \"function\" ? _ : constant(Array.from(_)), stack) : order;\n  };\n\n  stack.offset = function(_) {\n    return arguments.length ? (offset = _ == null ? offsetNone : _, stack) : offset;\n  };\n\n  return stack;\n}\n","export default function(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {\n    for (yp = yn = 0, i = 0; i < n; ++i) {\n      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {\n        d[0] = yp, d[1] = yp += dy;\n      } else if (dy < 0) {\n        d[1] = yn, d[0] = yn += dy;\n      } else {\n        d[0] = 0, d[1] = dy;\n      }\n    }\n  }\n}\n","import { bin as d3Bin, scaleOrdinal, stack, stackOffsetDiverging } from 'd3'\nimport { cloneDeep, fromPairs, groupBy, merge, uniq } from 'lodash-es'\nimport { getProperty, updateLegendAdditionalItems } from '@/tools'\nimport { color as colorConfigs, legend as legendConfigs } from '@/configuration'\nimport { histogram as histogramConfigs } from '@/configuration-non-customizable'\nimport { Events, ScaleTypes, ColorClassNameTypes } from '@/interfaces/enums'\nimport { formatDateTillMilliSeconds } from '@/services/time-series'\nimport type { ChartTabularData } from '@/interfaces/model'\n\nexport type StackKeysParams = {\n\tbins?: any\n\tgroups?: any\n\tpercentage?: any\n\tdivergent?: any\n}\n\nfunction _sanitizeCsvCell(cellContent: string): string {\n\tconst _trimmedCell = cellContent.trim()\n\tif (['=', '+', '-', '@', '\\t', '\\r'].includes(_trimmedCell.charAt(0))) {\n\t\treturn `\\xA0${_trimmedCell}`\n\t}\n\n\t// Only add quotes if cell contains commas, newlines, or quotes\n\tif (/[,\\\"\\n]/.test(_trimmedCell)) {\n\t\treturn `\"${_trimmedCell}\"`\n\t}\n\n\treturn _trimmedCell\n}\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class ChartModel {\n\tprotected services: any\n\n\t// Internal Model state\n\tprotected state: any = {\n\t\toptions: {}\n\t}\n\n\t// Data labels\n\t/**\n\t * A list of all the data groups that have existed within the lifetime of the chart\n\t * @type string[]\n\t */\n\tprotected allDataGroups: string[]\n\n\t// Fill scales & fill related objects\n\tprotected colorScale: any = {}\n\n\tprotected colorClassNames: any = {}\n\n\tconstructor(services: any) {\n\t\tthis.services = services\n\t}\n\n\tformatTable({ headers, cells }) {\n\t\tconst options = this.getOptions()\n\t\tconst {\n\t\t\tcode: localeCode,\n\t\t\tdate: dateFormatter,\n\t\t\tnumber: numberFormatter\n\t\t} = getProperty(options, 'locale')\n\t\tconst tableHeadingFormatter = getProperty(options, 'tabularRepModal', 'tableHeadingFormatter')\n\t\tconst tableCellFormatter = getProperty(options, 'tabularRepModal', 'tableCellFormatter')\n\t\tconst { cartesianScales } = this.services\n\t\tconst domainScaleType = cartesianScales?.getDomainAxisScaleType()\n\t\tlet domainValueFormatter: any\n\n\t\tif (domainScaleType === ScaleTypes.TIME) {\n\t\t\tdomainValueFormatter = (d: any) =>\n\t\t\t\tdateFormatter(d, localeCode, { month: 'short', day: 'numeric', year: 'numeric' })\n\t\t}\n\n\t\tconst result = [\n\t\t\ttypeof tableHeadingFormatter === 'function' ? tableHeadingFormatter(headers) : headers,\n\t\t\t...(typeof tableCellFormatter === 'function'\n\t\t\t\t? tableCellFormatter(cells)\n\t\t\t\t: cells.map((data: (string | number)[]) => {\n\t\t\t\t\t\tif (domainValueFormatter) {\n\t\t\t\t\t\t\tdata[1] = domainValueFormatter(data[1]) as string\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const i in data) {\n\t\t\t\t\t\t\tconst val = data[i]\n\t\t\t\t\t\t\tif (typeof val === 'number') {\n\t\t\t\t\t\t\t\tdata[i] = numberFormatter(val, localeCode)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn data\n\t\t\t\t\t}))\n\t\t]\n\t\treturn result\n\t}\n\n\tgetAllDataFromDomain(groups?: any) {\n\t\tif (!this.getData()) {\n\t\t\treturn null\n\t\t}\n\t\tconst options = this.getOptions()\n\t\t// Remove datasets that have been disabled\n\t\tlet allData = this.getData()\n\t\tconst dataGroups = this.getDataGroups()\n\t\tconst { groupMapsTo } = getProperty(options, 'data')\n\t\tconst axesOptions = getProperty(options, 'axes')\n\n\t\t// filter out the groups that are irrelevant to the component\n\t\tif (groups) {\n\t\t\tallData = allData.filter((item: any) => groups.includes(item[groupMapsTo]))\n\t\t}\n\n\t\tif (axesOptions) {\n\t\t\tObject.keys(axesOptions).forEach(axis => {\n\t\t\t\tconst mapsTo = axesOptions[axis].mapsTo\n\t\t\t\tconst scaleType = axesOptions[axis].scaleType\n\t\t\t\t// make sure linear/log values are numbers\n\t\t\t\tif (scaleType === ScaleTypes.LINEAR || scaleType === ScaleTypes.LOG) {\n\t\t\t\t\tallData = allData.map((datum: any) => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...datum,\n\t\t\t\t\t\t\t[mapsTo]: datum[mapsTo] === null ? datum[mapsTo] : Number(datum[mapsTo])\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\t// Check for custom domain\n\t\t\t\tif (mapsTo && axesOptions[axis].domain) {\n\t\t\t\t\tif (scaleType === ScaleTypes.LABELS) {\n\t\t\t\t\t\tallData = allData.filter((datum: any) =>\n\t\t\t\t\t\t\taxesOptions[axis].domain.includes(datum[mapsTo])\n\t\t\t\t\t\t)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst [start, end] = axesOptions[axis].domain\n\t\t\t\t\t\t// Filter out data outside domain if that datapoint is using that axis (has mapsTo property)\n\t\t\t\t\t\tallData = allData.filter(\n\t\t\t\t\t\t\t(datum: any) => !(mapsTo in datum) || (datum[mapsTo] >= start && datum[mapsTo] <= end)\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn allData.filter((datum: any) => {\n\t\t\treturn dataGroups.find((group: any) => group.name === datum[groupMapsTo])\n\t\t})\n\t}\n\n\t/**\n\t * Charts that have group configs passed into them, only want to retrieve the display data relevant to that chart\n\t * @param groups the included datasets for the particular chart\n\t */\n\tgetDisplayData(groups?: any) {\n\t\tif (!this.get('data')) {\n\t\t\treturn null\n\t\t}\n\n\t\tconst { ACTIVE } = legendConfigs.items.status\n\t\tconst dataGroups = this.getDataGroups(groups)\n\t\tconst { groupMapsTo } = this.getOptions().data\n\t\tconst allDataFromDomain = this.getAllDataFromDomain(groups)\n\n\t\treturn allDataFromDomain.filter((datum: any) => {\n\t\t\treturn dataGroups.find(\n\t\t\t\t(dataGroup: any) => dataGroup.name === datum[groupMapsTo] && dataGroup.status === ACTIVE\n\t\t\t)\n\t\t})\n\t}\n\n\tgetData() {\n\t\treturn this.get('data')\n\t}\n\n\tisDataEmpty() {\n\t\treturn !this.getData().length\n\t}\n\n\t/**\n\t * Sets the data for the current instance.\n\t *\n\t * This method sanitizes the provided data, generates data groups,\n\t * and updates the instance's state with the sanitized data and data groups.\n\t *\n\t * @param {any} newData - The new data to be set. This data will be cloned and sanitized.\n\t * @returns {any} - The sanitized version of the provided data.\n\t */\n\tsetData(newData: any) {\n\t\tconst sanitizedData = this.sanitize(cloneDeep(newData))\n\t\tconst dataGroups = this.generateDataGroups(sanitizedData)\n\n\t\tthis.set({\n\t\t\tdata: sanitizedData,\n\t\t\tdataGroups\n\t\t})\n\n\t\treturn sanitizedData\n\t}\n\n\tgetDataGroups(groups?: any) {\n\t\tconst isDataLoading = getProperty(this.getOptions(), 'data', 'loading')\n\n\t\t// No data should be displayed while data is still loading\n\t\tif (isDataLoading) {\n\t\t\treturn []\n\t\t}\n\n\t\t// if its a combo chart, the specific chart will pass the model the groups it needs\n\t\tif (groups) {\n\t\t\treturn this.get('dataGroups').filter((dataGroup: any) => groups.includes(dataGroup.name))\n\t\t}\n\t\treturn this.get('dataGroups')\n\t}\n\n\tgetActiveDataGroups(groups?: any) {\n\t\tconst { ACTIVE } = legendConfigs.items.status\n\n\t\treturn this.getDataGroups(groups).filter((dataGroup: any) => dataGroup.status === ACTIVE)\n\t}\n\n\tgetDataGroupNames(groups?: any) {\n\t\tconst dataGroups = this.getDataGroups(groups)\n\t\treturn dataGroups.map((dataGroup: any) => dataGroup.name)\n\t}\n\n\tgetActiveDataGroupNames(groups?: any) {\n\t\tconst activeDataGroups = this.getActiveDataGroups(groups)\n\t\treturn activeDataGroups.map((dataGroup: any) => dataGroup.name)\n\t}\n\n\tprivate aggregateBinDataByGroup(bin: any) {\n\t\treturn groupBy(bin, 'group')\n\t}\n\n\tgetBinConfigurations() {\n\t\t// Manipulate data and options for Histogram\n\t\tconst data = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\n\t\tconst mainXPos = this.services.cartesianScales.getMainXAxisPosition()\n\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier()\n\n\t\tconst axisOptions = options.axes[mainXPos]\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { bins: axisBins = histogramConfigs.defaultBins } = axisOptions\n\t\tconst areBinsDefined = Array.isArray(axisBins)\n\n\t\t// Get Histogram bins\n\t\tconst bins = d3Bin()\n\t\t\t.value((d: any) => d[domainIdentifier])\n\t\t\t.thresholds(axisBins)(data)\n\n\t\tif (!areBinsDefined) {\n\t\t\t// If bins are not defined by user\n\t\t\tconst binsWidth = bins[0].x1 - bins[0].x0\n\t\t\t// Set last bin width as the others\n\t\t\tbins[bins.length - 1].x1 = +bins[bins.length - 1].x0 + binsWidth\n\t\t} else {\n\t\t\t// Set last bin end as the last user defined one\n\t\t\tbins[bins.length - 1].x1 = axisBins[axisBins.length - 1]\n\t\t}\n\n\t\tconst binsDomain = areBinsDefined\n\t\t\t? [axisBins[0], axisBins[axisBins.length - 1]]\n\t\t\t: [bins[0].x0, bins[bins.length - 1].x1]\n\n\t\t// Get all groups\n\t\tconst groupsKeys = Array.from(new Set(data.map((d: any) => d[groupMapsTo])))\n\n\t\tconst histogramData = []\n\n\t\t// Group data by bin\n\t\tbins.forEach(bin => {\n\t\t\tconst key = `${bin.x0}-${bin.x1}`\n\t\t\tconst aggregateDataByGroup = this.aggregateBinDataByGroup(bin)\n\n\t\t\tgroupsKeys.forEach((group: string) => {\n\t\t\t\t// For each dataset put a bin with value 0 if not exist\n\t\t\t\t// (Scale X won't change when changing showed datasets)\n\t\t\t\thistogramData.push({\n\t\t\t\t\tgroup,\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue: aggregateDataByGroup[group] || 0,\n\t\t\t\t\tbin: bin.x0\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\n\t\treturn {\n\t\t\tbins,\n\t\t\tbinsDomain\n\t\t}\n\t}\n\n\tgetBinnedStackedData() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst dataGroupNames = this.getActiveDataGroupNames()\n\n\t\tconst { bins } = this.getBinConfigurations()\n\t\tconst dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys({\n\t\t\tbins\n\t\t})\n\n\t\treturn stack()\n\t\t\t.keys(dataGroupNames)(dataValuesGroupedByKeys)\n\t\t\t.map((series, i) => {\n\t\t\t\t// Add data group names to each series\n\t\t\t\treturn Object.keys(series)\n\t\t\t\t\t.filter((key: any) => !isNaN(key))\n\t\t\t\t\t.map((key: any) => {\n\t\t\t\t\t\tconst element = series[key]\n\t\t\t\t\t\telement[groupMapsTo] = dataGroupNames[i]\n\n\t\t\t\t\t\treturn element\n\t\t\t\t\t})\n\t\t\t})\n\t}\n\n\tgetGroupedData(groups?: any) {\n\t\tconst displayData = this.getDisplayData(groups)\n\t\tconst groupedData: any = {}\n\t\tconst { groupMapsTo } = this.getOptions().data\n\n\t\tdisplayData.map((datum: any) => {\n\t\t\tconst group = datum[groupMapsTo]\n\t\t\tif (groupedData[group] !== null && groupedData[group] !== undefined) {\n\t\t\t\tgroupedData[group].push(datum)\n\t\t\t} else {\n\t\t\t\tgroupedData[group] = [datum]\n\t\t\t}\n\t\t})\n\n\t\treturn Object.keys(groupedData).map(groupName => ({\n\t\t\tname: groupName,\n\t\t\tdata: groupedData[groupName]\n\t\t}))\n\t}\n\n\tgetStackKeys({ bins = null, groups = null }: StackKeysParams = { bins: null, groups: null }) {\n\t\tconst options = this.getOptions()\n\n\t\tconst displayData = this.getDisplayData(groups)\n\n\t\tlet stackKeys: any\n\t\tif (bins) {\n\t\t\tstackKeys = bins.map((bin: any) => `${bin.x0}:${bin.x1}`)\n\t\t} else {\n\t\t\tstackKeys = uniq(\n\t\t\t\tdisplayData.map((datum: any) => {\n\t\t\t\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier(datum)\n\n\t\t\t\t\t// Use time value as key for Date object to avoid multiple data in the same second\n\t\t\t\t\tif (datum[domainIdentifier] instanceof Date) {\n\t\t\t\t\t\treturn formatDateTillMilliSeconds(datum[domainIdentifier])\n\t\t\t\t\t}\n\n\t\t\t\t\treturn datum[domainIdentifier] && typeof datum[domainIdentifier].toString === 'function'\n\t\t\t\t\t\t? datum[domainIdentifier].toString()\n\t\t\t\t\t\t: datum[domainIdentifier]\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\n\t\tconst axisPosition = this.services.cartesianScales.domainAxisPosition\n\t\tconst scaleType = options.axes[axisPosition].scaleType\n\n\t\t// Sort keys\n\t\tif (scaleType === ScaleTypes.TIME) {\n\t\t\tstackKeys.sort((a: any, b: any) => {\n\t\t\t\tconst dateA: any = new Date(a)\n\t\t\t\tconst dateB: any = new Date(b)\n\n\t\t\t\treturn dateA - dateB\n\t\t\t})\n\t\t} else if (scaleType === ScaleTypes.LOG || scaleType === ScaleTypes.LINEAR) {\n\t\t\tstackKeys.sort((a: any, b: any) => a - b)\n\t\t}\n\n\t\treturn stackKeys\n\t}\n\n\tgetDataValuesGroupedByKeys({ bins = null, groups = null }: StackKeysParams) {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst displayData = this.getDisplayData(groups)\n\n\t\tconst dataGroupNames = this.getDataGroupNames()\n\n\t\tconst stackKeys = this.getStackKeys({ bins, groups })\n\t\tif (bins) {\n\t\t\treturn stackKeys.map((key: any) => {\n\t\t\t\tconst [binStart, binEnd] = key.split(':')\n\n\t\t\t\tconst correspondingValues: any = { x0: binStart, x1: binEnd }\n\t\t\t\tconst correspondingBin = bins.find((bin: any) => bin.x0.toString() === binStart.toString())\n\t\t\t\tdataGroupNames.forEach((dataGroupName: any) => {\n\t\t\t\t\tcorrespondingValues[dataGroupName] = correspondingBin.filter(\n\t\t\t\t\t\t(binItem: any) => binItem[groupMapsTo] === dataGroupName\n\t\t\t\t\t).length\n\t\t\t\t})\n\n\t\t\t\treturn correspondingValues\n\t\t\t}) as any\n\t\t}\n\n\t\treturn stackKeys.map((key: any) => {\n\t\t\tconst correspondingValues: any = { sharedStackKey: key }\n\t\t\tdataGroupNames.forEach((dataGroupName: any) => {\n\t\t\t\tconst correspondingDatum = displayData.find((datum: any) => {\n\t\t\t\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier(datum)\n\n\t\t\t\t\treturn (\n\t\t\t\t\t\tdatum[groupMapsTo] === dataGroupName &&\n\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(datum, domainIdentifier) &&\n\t\t\t\t\t\t(datum[domainIdentifier] instanceof Date\n\t\t\t\t\t\t\t? formatDateTillMilliSeconds(datum[domainIdentifier]) === key\n\t\t\t\t\t\t\t: datum[domainIdentifier].toString() === key)\n\t\t\t\t\t)\n\t\t\t\t})\n\n\t\t\t\tconst rangeIdentifier =\n\t\t\t\t\tthis.services.cartesianScales.getRangeIdentifier(correspondingValues)\n\t\t\t\tcorrespondingValues[dataGroupName] = correspondingDatum\n\t\t\t\t\t? correspondingDatum[rangeIdentifier]\n\t\t\t\t\t: null\n\t\t\t})\n\n\t\t\treturn correspondingValues\n\t\t}) as any\n\t}\n\n\tgetStackedData({ percentage = false, groups = null, divergent = false }: StackKeysParams) {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\t// Get only active data groups so non-active data groups are not rendered\n\t\t// on legend item click\n\t\tconst dataGroupNames = this.getActiveDataGroupNames(groups)\n\t\tconst dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys({\n\t\t\tgroups\n\t\t})\n\n\t\tif (percentage) {\n\t\t\tconst maxByKey = fromPairs(dataValuesGroupedByKeys.map((d: any) => [d.sharedStackKey, 0]))\n\n\t\t\tdataValuesGroupedByKeys.forEach((d: any) => {\n\t\t\t\tdataGroupNames.forEach((name: any) => {\n\t\t\t\t\tmaxByKey[d.sharedStackKey] += d[name]\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// cycle through data values to get percentage\n\t\t\tdataValuesGroupedByKeys.forEach((d: any) => {\n\t\t\t\tdataGroupNames.forEach((name: any) => {\n\t\t\t\t\tconst denominator: number = maxByKey[d.sharedStackKey] as number\n\t\t\t\t\tif (maxByKey[d.sharedStackKey]) {\n\t\t\t\t\t\td[name] = (d[name] / denominator) * 100\n\t\t\t\t\t} else {\n\t\t\t\t\t\td[name] = 0\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\n\t\tconst stackToUse = divergent ? stack().offset(stackOffsetDiverging) : stack()\n\n\t\treturn stackToUse\n\t\t\t.keys(dataGroupNames)(dataValuesGroupedByKeys)\n\t\t\t.map((series: any, i: number) => {\n\t\t\t\t// Add data group names to each series\n\t\t\t\treturn Object.keys(series)\n\t\t\t\t\t.filter((key: any) => !isNaN(key))\n\t\t\t\t\t.map((key: any) => {\n\t\t\t\t\t\tconst element = series[key]\n\t\t\t\t\t\telement[groupMapsTo] = dataGroupNames[i]\n\n\t\t\t\t\t\treturn element\n\t\t\t\t\t})\n\t\t\t})\n\t}\n\n\t/**\n\t * Retrieves the current options from the instance's state.\n\t *\n\t * @returns {any} - The current options stored in the instance's state.\n\t */\n\tgetOptions() {\n\t\treturn this.state.options\n\t}\n\n\tset(newState: any, configs?: any) {\n\t\tthis.state = Object.assign({}, this.state, newState)\n\t\tconst newConfig = Object.assign(\n\t\t\t{ skipUpdate: false, animate: true }, // default configs\n\t\t\tconfigs\n\t\t)\n\t\tif (!newConfig.skipUpdate) {\n\t\t\tthis.update(newConfig.animate)\n\t\t}\n\t}\n\n\tget(property?: string) {\n\t\tif (property) {\n\t\t\treturn this.state[property]\n\t\t} else {\n\t\t\treturn this.state\n\t\t}\n\t}\n\n\t/**\n\t * Updates the current options for the instance.\n\t *\n\t * This method retrieves the existing options, updates the legend additional items,\n\t * and merges the new options with the existing ones. The instance's state is then updated\n\t * with the merged options.\n\t *\n\t * @param {any} newOptions - The new options to be set. These options will be merged with the existing options.\n\t */\n\tsetOptions(newOptions: any) {\n\t\tconst options = this.getOptions()\n\t\tupdateLegendAdditionalItems(options, newOptions)\n\n\t\tthis.set({\n\t\t\toptions: merge(options, newOptions)\n\t\t})\n\t}\n\n\t/**\n\t *\n\t * Updates miscellanous information within the model\n\t * such as the color scales, or the legend data labels\n\t */\n\tupdate(animate = true) {\n\t\tif (!this.getDisplayData()) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.updateAllDataGroups()\n\n\t\tthis.setCustomColorScale()\n\t\tthis.setColorClassNames()\n\t\tthis.services.events.dispatchEvent(Events.Model.UPDATE, { animate })\n\t}\n\n\t/*\n\t * Data labels\n\t */\n\ttoggleDataLabel(changedLabel: string) {\n\t\tconst { ACTIVE, DISABLED } = legendConfigs.items.status\n\t\tconst dataGroups = this.getDataGroups()\n\n\t\tconst hasDeactivatedItems = dataGroups.some((group: any) => group.status === DISABLED)\n\t\tconst activeItems = dataGroups.filter((group: any) => group.status === ACTIVE)\n\n\t\t// If there are deactivated items, toggle \"changedLabel\"\n\t\tif (hasDeactivatedItems) {\n\t\t\t// If the only active item is being toggled\n\t\t\t// Activate all items\n\t\t\tif (activeItems.length === 1 && activeItems[0].name === changedLabel) {\n\t\t\t\t// If every item is active, then enable \"changedLabel\" and disable all other items\n\t\t\t\tdataGroups.forEach((_: any, i: number) => {\n\t\t\t\t\tdataGroups[i].status = ACTIVE\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconst indexToChange = dataGroups.findIndex((group: any) => group.name === changedLabel)\n\t\t\t\tdataGroups[indexToChange].status =\n\t\t\t\t\tdataGroups[indexToChange].status === DISABLED ? ACTIVE : DISABLED\n\t\t\t}\n\t\t} else {\n\t\t\t// If every item is active, then enable \"changedLabel\" and disable all other items\n\t\t\tdataGroups.forEach((group: any, i: number) => {\n\t\t\t\tdataGroups[i].status = group.name === changedLabel ? ACTIVE : DISABLED\n\t\t\t})\n\t\t}\n\n\t\t// Updates selected groups\n\t\tconst updatedActiveItems = dataGroups.filter((group: any) => group.status === ACTIVE)\n\t\tconst options = this.getOptions()\n\n\t\tconst hasUpdatedDeactivatedItems = dataGroups.some((group: any) => group.status === DISABLED)\n\n\t\t// If there are deactivated items, map the item name into selected groups\n\t\tif (hasUpdatedDeactivatedItems) {\n\t\t\toptions.data.selectedGroups = updatedActiveItems.map((activeItem: any) => activeItem.name)\n\t\t} else {\n\t\t\t// If every item is active, clear array\n\t\t\toptions.data.selectedGroups = []\n\t\t}\n\n\t\t// dispatch legend filtering event with the status of all the dataLabels\n\t\tthis.services.events.dispatchEvent(Events.Legend.ITEMS_UPDATE, {\n\t\t\tdataGroups\n\t\t})\n\n\t\t// Update model\n\t\tthis.set({\n\t\t\tdataGroups\n\t\t})\n\t}\n\n\t/**\n\t * Should the data point be filled?\n\t * @param group\n\t * @param key\n\t * @param data\n\t * @param defaultFilled the default for this chart\n\t */\n\tgetIsFilled(group: any, key?: any, data?: any, defaultFilled?: boolean) {\n\t\tconst options = this.getOptions()\n\t\tif (options.getIsFilled) {\n\t\t\treturn options.getIsFilled(group, key, data, defaultFilled)\n\t\t} else {\n\t\t\treturn defaultFilled\n\t\t}\n\t}\n\n\tgetFillColor(group: any, key?: any, data?: any) {\n\t\tconst options = this.getOptions()\n\t\tconst defaultFillColor = getProperty(this.colorScale, group)\n\n\t\tif (options.getFillColor) {\n\t\t\treturn options.getFillColor(group, key, data, defaultFillColor)\n\t\t} else {\n\t\t\treturn defaultFillColor\n\t\t}\n\t}\n\n\tgetStrokeColor(group: any, key?: any, data?: any) {\n\t\tconst options = this.getOptions()\n\t\tconst defaultStrokeColor = getProperty(this.colorScale, group)\n\n\t\tif (options.getStrokeColor) {\n\t\t\treturn options.getStrokeColor(group, key, data, defaultStrokeColor)\n\t\t} else {\n\t\t\treturn defaultStrokeColor\n\t\t}\n\t}\n\n\tisUserProvidedColorScaleValid() {\n\t\tconst userProvidedScale = getProperty(this.getOptions(), 'color', 'scale')\n\t\tconst dataGroups = this.getDataGroups()\n\n\t\tif (userProvidedScale == null || Object.keys(userProvidedScale).length == 0) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn dataGroups.some((dataGroup: any) =>\n\t\t\tObject.keys(userProvidedScale).includes(dataGroup.name)\n\t\t)\n\t}\n\n\tgetColorClassName(configs: {\n\t\tclassNameTypes?: ColorClassNameTypes[] // heatmaps do not pass this value\n\t\tdataGroupName?: string | number\n\t\toriginalClassName?: string\n\t\tvalue?: number // required for heatmap override\n\t}) {\n\t\tconst colorPairingTag = this.colorClassNames(configs.dataGroupName)\n\t\tlet className = configs.originalClassName\n\t\tconfigs.classNameTypes.forEach(\n\t\t\ttype =>\n\t\t\t\t(className = configs.originalClassName\n\t\t\t\t\t? `${className} ${type}-${colorPairingTag}`\n\t\t\t\t\t: `${type}-${colorPairingTag}`)\n\t\t)\n\n\t\treturn className || ''\n\t}\n\n\t/**\n\t * For charts that might hold an associated status for their dataset\n\t */\n\tgetStatus(): any {\n\t\treturn null\n\t}\n\n\tgetAllDataGroupsNames() {\n\t\treturn this.allDataGroups\n\t}\n\n\t/**\n\t * Converts data provided in the older format to tabular\n\t *\n\t */\n\tprotected transformToTabularData(data: any) {\n\t\tconsole.warn(\n\t\t\t\"We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://charts.carbondesignsystem.com/\"\n\t\t)\n\t\tconst tabularData: ChartTabularData = []\n\t\tconst { datasets, labels } = data\n\n\t\t// Loop through all datasets\n\t\tdatasets.forEach((dataset: any) => {\n\t\t\t// Update each data point to the new format\n\t\t\tdataset.data.forEach((datum: any, i: number) => {\n\t\t\t\tlet group\n\n\t\t\t\tconst datasetLabel = getProperty(dataset, 'label')\n\t\t\t\tif (datasetLabel === null) {\n\t\t\t\t\tconst correspondingLabel = getProperty(labels, i)\n\t\t\t\t\tif (correspondingLabel) {\n\t\t\t\t\t\tgroup = correspondingLabel\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroup = 'Ungrouped'\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tgroup = datasetLabel\n\t\t\t\t}\n\n\t\t\t\tconst updatedDatum: any = {\n\t\t\t\t\tgroup,\n\t\t\t\t\tkey: labels[i]\n\t\t\t\t}\n\n\t\t\t\tif (isNaN(datum)) {\n\t\t\t\t\tupdatedDatum['value'] = datum.value\n\t\t\t\t\tupdatedDatum['date'] = datum.date\n\t\t\t\t} else {\n\t\t\t\t\tupdatedDatum['value'] = datum\n\t\t\t\t}\n\n\t\t\t\ttabularData.push(updatedDatum)\n\t\t\t})\n\t\t})\n\n\t\treturn tabularData\n\t}\n\n\tgetTabularDataArray(): ChartTabularData {\n\t\t//apply tableFormatter\n\t\treturn []\n\t}\n\n\texportToCSV() {\n\t\tconst data = this.getTabularDataArray().map(row =>\n\t\t\trow.map((column: any) => {\n\t\t\t\tconst columnValue = column === '&ndash;' ? '–' : column\n\n\t\t\t\t// Split by separators and quotes, then sanitize each part individually\n\t\t\t\tconst sanitizedParts = columnValue.split(/[,;'\"`]/).map(part => _sanitizeCsvCell(part))\n\t\t\t\treturn `\"${sanitizedParts.join('')}\"`\n\t\t\t})\n\t\t)\n\n\t\tconst csvString = data.map(row => row.join(',')).join('\\n')\n\n\t\tconst options = this.getOptions()\n\n\t\tlet fileName = 'myChart'\n\t\tconst customFilename = getProperty(options, 'fileDownload', 'fileName')\n\n\t\tif (typeof customFilename === 'function') {\n\t\t\tfileName = customFilename('csv')\n\t\t} else if (typeof customFilename === 'string') {\n\t\t\tfileName = customFilename\n\t\t}\n\n\t\tthis.services.files.downloadCSV(csvString, `${fileName}.csv`)\n\t}\n\n\tprotected getTabularData(data: any) {\n\t\t// if data is not an array\n\t\tif (!Array.isArray(data)) {\n\t\t\treturn this.transformToTabularData(data)\n\t\t}\n\n\t\treturn data\n\t}\n\n\tprotected sanitize(data: any) {\n\t\tdata = this.getTabularData(data)\n\n\t\treturn data\n\t}\n\n\t/*\n\t * Data groups\n\t */\n\tprotected updateAllDataGroups() {\n\t\t// allDataGroups is used to generate a color scale that applies\n\t\t// to all the groups. Now when the data updates, you might remove a group,\n\t\t// and then bring it back in a newer data update, therefore\n\t\t// the order of the groups in allDataGroups matters so that you'd never\n\t\t// have an incorrect color assigned to a group.\n\n\t\t// Also, a new group should only be added to allDataGroups if\n\t\t// it doesn't currently exist\n\n\t\tif (!this.allDataGroups) {\n\t\t\tthis.allDataGroups = this.getDataGroupNames()\n\t\t} else {\n\t\t\t// Loop through current data groups\n\t\t\tthis.getDataGroupNames().forEach((dataGroupName: any) => {\n\t\t\t\t// If group name hasn't been stored yet, store it\n\t\t\t\tif (this.allDataGroups.indexOf(dataGroupName) === -1) {\n\t\t\t\t\tthis.allDataGroups.push(dataGroupName)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tprotected generateDataGroups(data: any) {\n\t\tconst { groupMapsTo } = this.getOptions().data\n\t\tconst { ACTIVE, DISABLED } = legendConfigs.items.status\n\t\tconst options = this.getOptions()\n\n\t\tconst uniqueDataGroups = uniq(data.map((datum: any) => datum[groupMapsTo]))\n\n\t\t// check if selectedGroups can be applied to chart with current data groups\n\t\tif (options.data.selectedGroups.length) {\n\t\t\tconst hasAllSelectedGroups = options.data.selectedGroups.every((groupName: any) =>\n\t\t\t\tuniqueDataGroups.includes(groupName)\n\t\t\t)\n\t\t\tif (!hasAllSelectedGroups) {\n\t\t\t\toptions.data.selectedGroups = []\n\t\t\t}\n\t\t}\n\n\t\t// Get group status based on items in selected groups\n\t\tconst getStatus = (groupName: any) =>\n\t\t\t!options.data.selectedGroups.length || options.data.selectedGroups.includes(groupName)\n\t\t\t\t? ACTIVE\n\t\t\t\t: DISABLED\n\n\t\treturn uniqueDataGroups.map(groupName => ({\n\t\t\tname: groupName,\n\t\t\tstatus: getStatus(groupName)\n\t\t}))\n\t}\n\n\t/*\n\t * Fill scales\n\t */\n\tprotected setCustomColorScale() {\n\t\tif (!this.isUserProvidedColorScaleValid()) {\n\t\t\treturn\n\t\t}\n\n\t\tconst options = this.getOptions()\n\t\tconst userProvidedScale = getProperty(options, 'color', 'scale')\n\n\t\tObject.keys(userProvidedScale).forEach(dataGroup => {\n\t\t\tif (!this.allDataGroups.includes(dataGroup)) {\n\t\t\t\tconsole.warn(`\"${dataGroup}\" does not exist in data groups.`)\n\t\t\t}\n\t\t})\n\n\t\t/**\n\t\t * Go through allDataGroups. If a data group has a color value provided\n\t\t * by the user, add that to the color range\n\t\t */\n\t\tconst providedDataGroups = this.allDataGroups.filter(dataGroup => userProvidedScale[dataGroup])\n\n\t\tprovidedDataGroups.forEach(\n\t\t\tdataGroup => (this.colorScale[dataGroup] = userProvidedScale[dataGroup])\n\t\t)\n\t}\n\n\t/*\n\t * Color palette\n\t */\n\tprotected setColorClassNames() {\n\t\tconst colorPairingOptions = getProperty(this.getOptions(), 'color', 'pairing')\n\n\t\t// Check if user has defined numberOfVariants (differ from given data)\n\t\tlet numberOfVariants = getProperty(colorPairingOptions, 'numberOfVariants')\n\t\tif (!numberOfVariants || numberOfVariants < this.allDataGroups.length) {\n\t\t\tnumberOfVariants = this.allDataGroups.length\n\t\t}\n\n\t\tlet pairingOption = getProperty(colorPairingOptions, 'option')\n\t\tconst colorPairingCounts = colorConfigs.pairingOptions\n\n\t\t// If number of dataGroups is greater than 5, user 14-color palette\n\t\tconst numberOfColors = numberOfVariants > 5 ? 14 : numberOfVariants\n\n\t\t// Use default palette if user choice is not in range\n\t\tconst key = `${numberOfColors}-color` as keyof typeof colorPairingCounts\n\t\tpairingOption = pairingOption <= colorPairingCounts[key] ? pairingOption : 1\n\n\t\t// Create color classes for graph, tooltip and stroke use\n\t\tconst colorPairing = this.allDataGroups.map(\n\t\t\t(_, index) => `${numberOfColors}-${pairingOption}-${(index % 14) + 1}`\n\t\t)\n\n\t\t// Create default color classnames\n\t\tthis.colorClassNames = scaleOrdinal().range(colorPairing).domain(this.allDataGroups)\n\t}\n}\n","import { cloneDeep, uniq } from 'lodash-es'\nimport { getProperty } from '@/tools'\nimport { ChartModel } from './model'\nimport { ScaleTypes, AxisPositions, AxisFlavor } from '@/interfaces/enums'\n\n/**\n * This supports adding X and Y Cartesian[2D] zoom data to a ChartModel\n * */\nexport class ChartModelCartesian extends ChartModel {\n\taxisFlavor = AxisFlavor.DEFAULT // can't be protected as it's used by two-dimensional-axes.ts\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\t// get the scales information\n\t// needed for getTabularArray()\n\tprotected assignRangeAndDomains() {\n\t\tconst { cartesianScales } = this.services\n\t\tconst options = this.getOptions()\n\t\tconst isDualAxes = cartesianScales.isDualAxes()\n\n\t\tconst scales = {\n\t\t\tprimaryDomain: cartesianScales.domainAxisPosition,\n\t\t\tprimaryRange: cartesianScales.rangeAxisPosition,\n\t\t\tsecondaryDomain: null as any,\n\t\t\tsecondaryRange: null as any\n\t\t}\n\t\tif (isDualAxes) {\n\t\t\tscales.secondaryDomain = cartesianScales.secondaryDomainAxisPosition\n\t\t\tscales.secondaryRange = cartesianScales.secondaryRangeAxisPosition\n\t\t}\n\n\t\tObject.keys(scales).forEach(\n\t\t\t(scale: 'primaryDomain' | 'primaryRange' | 'secondaryDomain' | 'secondaryRange') => {\n\t\t\t\tconst position = scales[scale]\n\t\t\t\tif (cartesianScales.scales[position]) {\n\t\t\t\t\tscales[scale] = {\n\t\t\t\t\t\tposition: position,\n\t\t\t\t\t\tlabel: cartesianScales.getScaleLabel(position),\n\t\t\t\t\t\tidentifier: getProperty(options, 'axes', position, 'mapsTo')\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tscales[scale] = null\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\treturn scales\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { primaryDomain, primaryRange, secondaryDomain, secondaryRange } =\n\t\t\tthis.assignRangeAndDomains()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tconst headers = [\n\t\t\t'Group',\n\t\t\tprimaryDomain.label,\n\t\t\tprimaryRange.label,\n\t\t\t...(secondaryDomain ? [secondaryDomain.label] : []),\n\t\t\t...(secondaryRange ? [secondaryRange.label] : [])\n\t\t]\n\t\tconst cells = displayData.map((datum: any) => [\n\t\t\tdatum[groupMapsTo],\n\t\t\tdatum[primaryDomain.identifier] === null ? '&ndash;' : datum[primaryDomain.identifier],\n\t\t\tdatum[primaryRange.identifier] === null || isNaN(datum[primaryRange.identifier])\n\t\t\t\t? '&ndash;'\n\t\t\t\t: numberFormatter(datum[primaryRange.identifier], localeCode),\n\t\t\t...(secondaryDomain\n\t\t\t\t? [\n\t\t\t\t\t\tdatum[secondaryDomain.identifier] === null\n\t\t\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t\t\t: datum[secondaryDomain.identifier]\n\t\t\t\t\t]\n\t\t\t\t: []),\n\t\t\t...(secondaryRange\n\t\t\t\t? [\n\t\t\t\t\t\tdatum[secondaryRange.identifier] === null || isNaN(datum[secondaryRange.identifier])\n\t\t\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t\t\t: datum[secondaryRange.identifier]\n\t\t\t\t\t]\n\t\t\t\t: [])\n\t\t])\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\tsetData(newData: any) {\n\t\tlet data: any\n\t\tif (newData) {\n\t\t\tdata = super.setData(newData)\n\t\t\tif (getProperty(this.getOptions(), 'zoomBar', AxisPositions.TOP, 'enabled')) {\n\t\t\t\t// get pre-defined zoom bar data\n\t\t\t\tconst definedZoomBarData = getProperty(\n\t\t\t\t\tthis.getOptions(),\n\t\t\t\t\t'zoomBar',\n\t\t\t\t\tAxisPositions.TOP,\n\t\t\t\t\t'data'\n\t\t\t\t)\n\t\t\t\t// if we have zoom bar data we need to update it as well\n\t\t\t\t// with pre-defined zoom bar data\n\t\t\t\tthis.setZoomBarData(definedZoomBarData)\n\t\t\t}\n\t\t}\n\n\t\treturn data\n\t}\n\n\t/**\n\t * Sets the zoom bar data for the current instance.\n\t *\n\t * This method sanitizes the provided zoom bar data or uses the display data if no explicit\n\t * zoom data is provided. It normalizes the zoom bar data by aggregating values based on unique\n\t * dates and updates the instance's state with the normalized data.\n\t *\n\t * @param {any} [newZoomBarData] - The new zoom bar data to be set. If not provided, the display data will be used.\n\t */\n\tsetZoomBarData(newZoomBarData?: any) {\n\t\tconst sanitizedData = newZoomBarData\n\t\t\t? this.sanitize(cloneDeep(newZoomBarData))\n\t\t\t: this.getDisplayData() // if we're not passed explicit zoom data use the model\n\n\t\tlet zoomBarNormalizedValues = sanitizedData\n\n\t\tconst { cartesianScales } = this.services\n\t\tif (sanitizedData && cartesianScales.domainAxisPosition && cartesianScales.rangeAxisPosition) {\n\t\t\tconst domainIdentifier = cartesianScales.getDomainIdentifier()\n\t\t\tconst rangeIdentifier = cartesianScales.getRangeIdentifier()\n\t\t\t// get all dates (Number) in displayData\n\t\t\tlet allDates = sanitizedData.map((datum: any) => datum[domainIdentifier].getTime())\n\t\t\tallDates = uniq(allDates).sort()\n\n\t\t\t// Go through all date values\n\t\t\t// And get corresponding data from each dataset\n\t\t\tzoomBarNormalizedValues = allDates.map((date: Date) => {\n\t\t\t\tlet sum = 0\n\t\t\t\tconst datum: any = {}\n\n\t\t\t\tsanitizedData.forEach((data: any) => {\n\t\t\t\t\tif (data[domainIdentifier].getTime() === date) {\n\t\t\t\t\t\tsum += data[rangeIdentifier]\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tdatum[domainIdentifier] = new Date(date)\n\t\t\t\tdatum[rangeIdentifier] = sum\n\n\t\t\t\treturn datum\n\t\t\t})\n\t\t}\n\n\t\tthis.set({ zoomBarData: zoomBarNormalizedValues })\n\t}\n\n\tgetZoomBarData() {\n\t\treturn this.get('zoomBarData')\n\t}\n\n\tprotected sanitizeDateValues(data: any) {\n\t\tconst options = this.getOptions()\n\n\t\tif (!options.axes) {\n\t\t\treturn data\n\t\t}\n\n\t\tconst keysToCheck: any[] = []\n\t\tObject.keys(AxisPositions).forEach((axisPositionKey: keyof typeof AxisPositions) => {\n\t\t\tconst axisPosition = AxisPositions[axisPositionKey]\n\t\t\tconst axisOptions = options.axes[axisPosition]\n\n\t\t\tif (axisOptions && axisOptions.scaleType === ScaleTypes.TIME) {\n\t\t\t\tconst axisMapsTo = axisOptions.mapsTo\n\n\t\t\t\tif (axisMapsTo !== null || axisMapsTo !== undefined) {\n\t\t\t\t\tkeysToCheck.push(axisMapsTo)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tif (keysToCheck.length > 0) {\n\t\t\t// Check all datapoints and sanitize dates\n\t\t\tdata.forEach((datum: any) => {\n\t\t\t\tkeysToCheck.forEach((key: any) => {\n\t\t\t\t\tif (getProperty(datum, key, 'getTime') === null) {\n\t\t\t\t\t\tdatum[key] = new Date(datum[key])\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\n\t\treturn data\n\t}\n\n\tprotected sanitize(data: any) {\n\t\tdata = super.sanitize(data)\n\t\tdata = this.sanitizeDateValues(data)\n\n\t\treturn data\n\t}\n}\n","// Internal Imports\nimport { ChartModelCartesian } from './cartesian-charts'\nimport { getProperty } from '@/tools'\n/**\n * Alluvial chart model layer\n */\nexport class AlluvialChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\t// Sort array by source to get a close depiction of the alluvial chart\n\t\tdisplayData.sort((a: any, b: any) => a['source'].localeCompare(b['source']))\n\t\tconst headers = ['Source', 'Target', 'Value']\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum['source'],\n\t\t\t\tdatum['target'],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { ascending, min, max, quantile, scaleOrdinal } from 'd3'\nimport { getProperty } from '@/tools'\nimport { color as colorConfigs } from '@/configuration'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class BoxplotChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetBoxQuartiles(d: any) {\n\t\treturn {\n\t\t\tq_25: quantile(d, 0.25),\n\t\t\tq_50: quantile(d, 0.5),\n\t\t\tq_75: quantile(d, 0.75)\n\t\t}\n\t}\n\n\tgetBoxplotData() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst groupedData = this.getGroupedData()\n\n\t\t// Prepare the data for the box plots\n\t\tconst boxplotData = []\n\t\tfor (const { name: group, data } of groupedData) {\n\t\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\t\t\tconst values = data.map((d: any) => d[rangeIdentifier]).sort(ascending)\n\n\t\t\tconst record = {\n\t\t\t\t[groupMapsTo]: group,\n\t\t\t\tcounts: values,\n\t\t\t\tquartiles: this.getBoxQuartiles(values),\n\t\t\t\toutliers: null as any,\n\t\t\t\twhiskers: null as any\n\t\t\t}\n\n\t\t\tconst q1 = record.quartiles.q_25\n\t\t\tconst q3 = record.quartiles.q_75\n\n\t\t\tconst iqr = (q3 - q1) * 1.5\n\t\t\tconst irq1 = q1 - iqr\n\t\t\tconst irq3 = q3 + iqr\n\n\t\t\tconst outliers = []\n\t\t\tconst normalValues = []\n\n\t\t\tfor (const value of values) {\n\t\t\t\tif (value < irq1) {\n\t\t\t\t\toutliers.push(value)\n\t\t\t\t} else if (value > irq3) {\n\t\t\t\t\toutliers.push(value)\n\t\t\t\t} else {\n\t\t\t\t\tnormalValues.push(value)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trecord.outliers = outliers\n\n\t\t\tconst minNormalValue = min(normalValues)\n\t\t\tconst maxNormalValue = max(normalValues)\n\t\t\trecord.whiskers = {\n\t\t\t\tmin: minNormalValue\n\t\t\t\t\t? minNormalValue\n\t\t\t\t\t: min([record.quartiles.q_25, record.quartiles.q_50, record.quartiles.q_75]),\n\t\t\t\tmax: maxNormalValue\n\t\t\t\t\t? maxNormalValue\n\t\t\t\t\t: max([record.quartiles.q_25, record.quartiles.q_50, record.quartiles.q_75])\n\t\t\t}\n\n\t\t\tboxplotData.push(record)\n\t\t}\n\n\t\treturn boxplotData\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst boxplotData = this.getBoxplotData()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(options, 'locale')\n\n\t\tconst headers = ['Group', 'Minimum', 'Q1', 'Median', 'Q3', 'Maximum', 'IQR', 'Outlier(s)']\n\t\tconst cells = [\n\t\t\t...boxplotData.map(datum => {\n\t\t\t\tlet outliers = getProperty(datum, 'outliers')\n\t\t\t\tif (outliers === null || outliers.length === 0) {\n\t\t\t\t\toutliers = ['&ndash;']\n\t\t\t\t}\n\t\t\t\treturn [\n\t\t\t\t\tdatum[groupMapsTo],\n\t\t\t\t\tgetProperty(datum, 'whiskers', 'min') !== null\n\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'whiskers', 'min'), localeCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_25') !== null\n\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'quartiles', 'q_25'), localeCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_50') !== null\n\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'quartiles', 'q_50'), localeCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_75') !== null\n\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'quartiles', 'q_75'), localeCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'whiskers', 'max') !== null\n\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'whiskers', 'max'), localeCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_75') !== null &&\n\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_25') !== null\n\t\t\t\t\t\t? (numberFormatter(\n\t\t\t\t\t\t\t\tgetProperty(datum, 'quartiles', 'q_75') - getProperty(datum, 'quartiles', 'q_25')\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tlocaleCode)\n\t\t\t\t\t\t: '&ndash;',\n\t\t\t\t\toutliers.map((d: any) => numberFormatter(d, localeCode)).join(',')\n\t\t\t\t]\n\t\t\t})\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\tprotected setColorClassNames() {\n\t\t// monochrome\n\t\tconst numberOfColors = 1\n\n\t\tconst colorPairingOptions = getProperty(this.getOptions(), 'color', 'pairing')\n\t\tlet pairingOption = getProperty(colorPairingOptions, 'option')\n\t\tconst colorPairingCounts = colorConfigs.pairingOptions\n\n\t\t// Use default palette if user choice is not in range\n\t\tpairingOption =\n\t\t\tpairingOption <= colorPairingCounts[`${numberOfColors}-color`] ? pairingOption : 1\n\n\t\t// Create color classes for graph, tooltip and stroke use\n\t\tconst colorPairing = this.allDataGroups.map(() => `${numberOfColors}-${pairingOption}-1`)\n\n\t\t// Create default color classnames\n\t\tthis.colorClassNames = scaleOrdinal().range(colorPairing).domain(this.allDataGroups)\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/**\n * Bullet chart model layer\n */\nexport class BulletChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\t/**\n\t * Determines the index of the performance area titles to use\n\t * @param datum\n\t * @returns number\n\t */\n\tgetMatchingRangeIndexForDatapoint(datum: any) {\n\t\tlet matchingRangeIndex\n\t\tfor (let i = datum.ranges.length - 1; i > 0; i--) {\n\t\t\tconst range = datum.ranges[i]\n\t\t\tif (datum.value >= range) {\n\t\t\t\tmatchingRangeIndex = i\n\n\t\t\t\treturn matchingRangeIndex\n\t\t\t}\n\t\t}\n\n\t\treturn 0\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(options, 'locale')\n\n\t\tconst performanceAreaTitles = getProperty(options, 'bullet', 'performanceAreaTitles')\n\t\tconst headers = ['Title', 'Group', 'Value', 'Target', 'Percentage', 'Performance']\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum['title'],\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode),\n\t\t\t\tgetProperty(datum, 'marker') === null\n\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t: numberFormatter(datum['marker'], localeCode),\n\t\t\t\tgetProperty(datum, 'marker') === null\n\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t: `${numberFormatter(Math.floor((datum[rangeIdentifier] / datum.marker) * 100), localeCode)}%`,\n\t\t\t\tperformanceAreaTitles[this.getMatchingRangeIndexForDatapoint(datum)]\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","// External Imports\nimport { isEmpty } from 'lodash-es'\n\n// Internal Imports\nimport { ChartModel } from './model'\nimport { getProperty } from '@/tools'\nimport { getColorScale } from '@/services/color-scale-utils'\n\n/**\n * Base thematic maps chart model layer\n */\nexport class ChoroplethModel extends ChartModel {\n\tprivate _colorScale: any = undefined\n\n\t// Holds a mapping of geometry objects to data objects\n\t// Allows us to access data faster\n\tprivate _matrix = {}\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\t/**\n\t * @override\n\t * @param value\n\t * @returns string\n\t */\n\tgetFillColor(value: number) {\n\t\treturn this._colorScale(value)\n\t}\n\n\t/**\n\t * Helper function that will generate a dictionary\n\t */\n\tgetCombinedData() {\n\t\tif (isEmpty(this._matrix)) {\n\t\t\tconst options = this.getOptions()\n\t\t\tconst data = this.getDisplayData()\n\t\t\tif (!isEmpty(data) && !isEmpty(options.geoData.objects.countries)) {\n\t\t\t\t/**\n\t\t\t\t * @todo\n\t\t\t\t * We can either use name or id by default to generate this dictionary\n\t\t\t\t * Curently id & name are standard in geoJSON. Unfortunately, topojson does not have any standard\n\t\t\t\t * so feature objects can have any key. We suggest that they include name or id at the very least\n\t\t\t\t *\n\t\t\t\t * May need to provide users with the option to pass in keys to create dictionary with\n\t\t\t\t */\n\t\t\t\toptions.geoData.objects.countries.geometries.forEach(country => {\n\t\t\t\t\tthis._matrix[country.properties.NAME] = country\n\t\t\t\t})\n\n\t\t\t\tdata.forEach(value => {\n\t\t\t\t\tif (this._matrix[value.name]) {\n\t\t\t\t\t\tthis._matrix[value.name]['value'] = value.value || null\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn(`Data point ${value} is missing geographical data.`)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\treturn this._matrix\n\t}\n\n\t/**\n\t * Generate tabular data from display data\n\t * @returns Array<Object>\n\t */\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tconst headers = ['Country ID', 'Country Name', 'Value']\n\t\tconst cells = [\n\t\t\t...displayData.map(datum => [\n\t\t\t\tdatum['id'] === null ? '&ndash;' : datum['id'],\n\t\t\t\tdatum['name'],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\t// Uses quantize scale to return class names\n\tgetColorClassName(configs: { value?: number; originalClassName?: string }) {\n\t\treturn `${configs.originalClassName} ${this._colorScale(configs.value as number)}`\n\t}\n\n\tprotected setColorClassNames() {\n\t\tconst colorOptions = getProperty(this.getOptions(), 'color')\n\t\tthis._colorScale = getColorScale(this.getDisplayData(), colorOptions)\n\t}\n}\n","import { merge } from 'lodash-es'\nimport { getProperty, updateLegendAdditionalItems } from '@/tools'\nimport { ChartModel } from './model'\nimport { LegendItemType } from '@/interfaces/enums'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class CirclePackChartModel extends ChartModel {\n\tparentNode = false\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t\tthis.set({ depth: 2 }, { skipUpdate: true })\n\t}\n\n\tsetData(newData: any) {\n\t\tsuper.setData(newData)\n\t\tthis.setDataGroups()\n\t\tif (newData.length === 1) {\n\t\t\tthis.parentNode = true\n\t\t}\n\t\tthis.setZoom()\n\t}\n\n\tsetOptions(newOptions: any) {\n\t\tconst options = this.getOptions()\n\t\tconst zoomOptions = merge({}, newOptions, this.getZoomOptions(newOptions))\n\t\tupdateLegendAdditionalItems(options, zoomOptions)\n\n\t\tconst depth = this.getHierarchyLevel()\n\t\tconst userProvidedDepth = getProperty(options, 'circlePack', 'depth')\n\n\t\tthis.set({\n\t\t\toptions: merge(options, zoomOptions),\n\t\t\tdepth: userProvidedDepth && userProvidedDepth < 4 ? userProvidedDepth : depth\n\t\t})\n\t}\n\n\tgetZoomOptions(options?: any) {\n\t\tif (!this.getDisplayData()) {\n\t\t\treturn {}\n\t\t}\n\t\t// uses the user provided options and data to determine if there is zoom in this CP chart\n\t\tconst displayData = this.getDisplayData()\n\t\tconst zoomOptions = options ? options : this.getOptions()\n\t\tconst data =\n\t\t\tdisplayData.length === 1 && getProperty(displayData, 0, 'children')\n\t\t\t\t? getProperty(displayData, 0, 'children')\n\t\t\t\t: displayData\n\n\t\tlet depth = this.getHierarchyLevel()\n\t\t// check the data depth\n\t\tdata.some((datum: any) => {\n\t\t\tif (datum.children) {\n\t\t\t\tif (datum.children.some((item: any) => item.children)) {\n\t\t\t\t\tdepth = 3\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tif (getProperty(zoomOptions, 'canvasZoom', 'enabled') === true && depth > 2) {\n\t\t\treturn {\n\t\t\t\tlegend: {\n\t\t\t\t\tadditionalItems: [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: LegendItemType.ZOOM,\n\t\t\t\t\t\t\tname: 'Click to zoom'\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n\n\tsetZoom(options?: any) {\n\t\tthis.setOptions(this.getZoomOptions(options))\n\t}\n\n\t// update the hierarchy level\n\tupdateHierarchyLevel(depth: number) {\n\t\tthis.set({ depth: depth })\n\t}\n\n\tgetHierarchyLevel() {\n\t\treturn this.get('depth')\n\t}\n\n\thasParentNode() {\n\t\treturn this.parentNode\n\t}\n\n\t// set the datagroup name on the items that are it's children\n\tsetDataGroups() {\n\t\tconst data = this.getData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\n\t\tconst newData = data.map((depthOne: any) => {\n\t\t\tconst groupName = depthOne[groupMapsTo]\n\t\t\treturn this.setChildrenDataGroup(depthOne, groupName)\n\t\t})\n\n\t\tthis.set(\n\t\t\t{\n\t\t\t\tdata: newData\n\t\t\t},\n\t\t\t{ skipUpdate: true }\n\t\t)\n\t}\n\n\t// sets name recursively down the node tree\n\tprotected setChildrenDataGroup(node: any, name: any) {\n\t\tif (node.children) {\n\t\t\treturn {\n\t\t\t\t...node,\n\t\t\t\tdataGroupName: name,\n\t\t\t\tchildren: node.children.map((child: any) => {\n\t\t\t\t\treturn this.setChildrenDataGroup(child, name)\n\t\t\t\t})\n\t\t\t}\n\t\t} else {\n\t\t\treturn { ...node, dataGroupName: name }\n\t\t}\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tconst headers = ['Child', 'Parent', 'Value']\n\t\tconst cells = []\n\n\t\tdisplayData.forEach((datum: any) => {\n\t\t\tlet value = datum.value ? datum.value : 0\n\t\t\tif (datum.children) {\n\t\t\t\t// Call recursive function\n\t\t\t\tvalue += this.getChildrenDatums(datum.children, datum.name, cells, 0)\n\t\t\t}\n\t\t\tcells.push(['&ndash;', datum.name, numberFormatter(value, localeCode)])\n\t\t})\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\t/**\n\t * Recursively determine the relationship between all the nested elements in the child\n\t * @private\n\t * @param {any} children - The children nodes to process.\n\t * @param {any} parent - The parent node associated with the children.\n\t * @param {string[][]} [result=[]] - An array to accumulate the resulting data.\n\t * @param {number} [totalSum=0] - The running total sum of values processed.\n\t * @returns {number} Sum.\n\t */\n\tprivate getChildrenDatums(children: any, parent: any, result: string[][] = [], totalSum = 0) {\n\t\tconst grandParent = parent\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tchildren.forEach((child: any) => {\n\t\t\tconst parentWithinIteration = child.name\n\t\t\tlet sum = 0\n\n\t\t\tif (child.children) {\n\t\t\t\tif (child.children.length > 0) {\n\t\t\t\t\tif (typeof child.value === 'number') {\n\t\t\t\t\t\ttotalSum += child.value\n\t\t\t\t\t}\n\n\t\t\t\t\tsum += this.getChildrenDatums(child.children, parentWithinIteration, result, sum)\n\t\t\t\t\tresult.push([parentWithinIteration, grandParent, numberFormatter(sum, localeCode)])\n\t\t\t\t\ttotalSum += sum\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet value = 0\n\t\t\t\tif (typeof child.value === 'number') {\n\t\t\t\t\tvalue = child.value\n\t\t\t\t\ttotalSum += child.value\n\t\t\t\t}\n\t\t\t\tresult.push([child.name, grandParent, numberFormatter(value, localeCode)])\n\t\t\t}\n\t\t})\n\n\t\treturn totalSum\n\t}\n}\n","import { ChartModel } from './model'\nimport { getProperty } from '@/tools'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class PieChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularData(data: any) {\n\t\tconst tabularData = super.getTabularData(data)\n\n\t\t// if the data was changed to tabular format\n\t\t// update the group to the key so the slices render with the correct tooltips and colors\n\t\tif (data !== tabularData) {\n\t\t\t// If a label was set for the overall dataset, reassign it to key value\n\t\t\ttabularData.forEach((d: any) => {\n\t\t\t\tif (d.key && d.key !== d.group) {\n\t\t\t\t\td.group = d.key\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn tabularData\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { valueMapsTo } = options.pie\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(options, 'locale')\n\n\t\tconst headers = ['Group', 'Value']\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tdatum[valueMapsTo] === null ? '&ndash;' : numberFormatter(datum[valueMapsTo], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\tsanitize(data: any) {\n\t\tconst tabularData = this.getTabularData(data)\n\n\t\t// Sort data based on value\n\t\treturn tabularData.sort((a, b) => b.value - a.value)\n\t}\n}\n","import { ChartModel } from './model'\nimport { getProperty } from '@/tools'\n\n/**\n * The gauge chart model layer\n */\nexport class GaugeChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetDataGroups() {\n\t\treturn super.getDataGroups().filter((item: any) => item.name !== 'delta')\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tconst headers = ['Group', 'Value']\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { extent, scaleQuantize, scaleLinear } from 'd3'\nimport { cloneDeep, isEmpty } from 'lodash-es'\nimport { getProperty } from '@/tools'\nimport { AxisFlavor, ScaleTypes } from '@/interfaces/enums'\nimport { getColorScale } from '@/services'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/** The gauge chart model layer */\nexport class HeatmapModel extends ChartModelCartesian {\n\taxisFlavor = AxisFlavor.HOVERABLE\n\tprivate _colorScale: any = undefined\n\n\t// List of unique ranges and domains\n\tprivate _domains: any[] = []\n\tprivate _ranges: any[] = []\n\n\tprivate _matrix: any = {}\n\n\tconstructor(services: any) {\n\t\tsuper(services)\n\n\t\t// Check which scale types are being used\n\t\tconst axis = getProperty(this.getOptions(), 'axes')\n\n\t\t// Need to check options since scale service hasn't been instantiated\n\t\tif (\n\t\t\t(!!getProperty(axis, 'left', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'left', 'scaleType') !== ScaleTypes.LABELS) ||\n\t\t\t(!!getProperty(axis, 'right', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'right', 'scaleType') !== ScaleTypes.LABELS) ||\n\t\t\t(!!getProperty(axis, 'top', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'top', 'scaleType') !== ScaleTypes.LABELS) ||\n\t\t\t(!!getProperty(axis, 'bottom', 'scaleType') &&\n\t\t\t\tgetProperty(axis, 'bottom', 'scaleType') !== ScaleTypes.LABELS)\n\t\t) {\n\t\t\tthrow Error('Heatmap only supports label scaletypes.')\n\t\t}\n\t}\n\n\t/**\n\t * Get min and maximum value of the display data\n\t * @returns Array consisting of smallest and largest values in  data\n\t */\n\tgetValueDomain() {\n\t\tconst limits = extent(this.getDisplayData(), (d: any) => d.value)\n\t\tconst domain = scaleLinear()\n\t\t\t.domain(limits as [number, number])\n\t\t\t.nice()\n\t\t\t.domain()\n\n\t\t// Ensuring limits start at 0 to make scale look more `nicer`\n\t\tif (domain[0] > 0) {\n\t\t\tdomain[0] = 0\n\t\t} else if (domain[0] === 0 && domain[1] === 0) {\n\t\t\t// Range cannot be between 0 and 0 (itself)\n\t\t\treturn [0, 1]\n\t\t}\n\n\t\t// Ensure the median of the range is 0 if domain extends into both negative & positive\n\t\tif (domain[0] < 0 && domain[1] > 0) {\n\t\t\tif (Math.abs(domain[0]) > domain[1]) {\n\t\t\t\tdomain[1] = Math.abs(domain[0])\n\t\t\t} else {\n\t\t\t\tdomain[0] = -domain[1]\n\t\t\t}\n\t\t}\n\n\t\treturn domain\n\t}\n\n\t/**\n\t * @override\n\t * @param value\n\t * @returns string\n\t */\n\tgetFillColor(value: number) {\n\t\treturn this._colorScale(value)\n\t}\n\n\t/**\n\t * Generate a list of all unique domains\n\t * @returns String[]\n\t */\n\tgetUniqueDomain(): string[] {\n\t\tif (isEmpty(this._domains)) {\n\t\t\tconst displayData = this.getDisplayData()\n\t\t\tconst { cartesianScales } = this.services\n\n\t\t\tconst domainIdentifier = cartesianScales.getDomainIdentifier()\n\t\t\tconst mainXAxisPosition = cartesianScales.getMainXAxisPosition()\n\t\t\tconst customDomain = cartesianScales.getCustomDomainValuesByposition(mainXAxisPosition)\n\n\t\t\t// Use user defined domain if specified\n\t\t\tif (customDomain) {\n\t\t\t\treturn customDomain\n\t\t\t}\n\n\t\t\t// Get unique axis values & create a matrix\n\t\t\tthis._domains = Array.from(\n\t\t\t\tnew Set(\n\t\t\t\t\tdisplayData.map((d: any) => {\n\t\t\t\t\t\treturn d[domainIdentifier]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn this._domains\n\t}\n\n\t/**\n\t * Generates a list of all unique ranges\n\t * @returns String[]\n\t */\n\tgetUniqueRanges(): string[] {\n\t\tif (isEmpty(this._ranges)) {\n\t\t\tconst displayData = this.getDisplayData()\n\t\t\tconst { cartesianScales } = this.services\n\n\t\t\tconst rangeIdentifier = cartesianScales.getRangeIdentifier()\n\t\t\tconst mainYAxisPosition = cartesianScales.getMainYAxisPosition()\n\t\t\tconst customDomain = cartesianScales.getCustomDomainValuesByposition(mainYAxisPosition)\n\n\t\t\t// Use user defined domain if specified\n\t\t\tif (customDomain) {\n\t\t\t\treturn customDomain\n\t\t\t}\n\n\t\t\t// Get unique axis values & create a matrix\n\t\t\tthis._ranges = Array.from(\n\t\t\t\tnew Set(\n\t\t\t\t\tdisplayData.map((d: any) => {\n\t\t\t\t\t\treturn d[rangeIdentifier]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\treturn this._ranges\n\t}\n\n\t/**\n\t * Generates a matrix (If doesn't exist) and returns it\n\t * @returns Object\n\t */\n\tgetMatrix() {\n\t\tif (isEmpty(this._matrix)) {\n\t\t\tconst uniqueDomain = this.getUniqueDomain()\n\t\t\tconst uniqueRange = this.getUniqueRanges()\n\n\t\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier()\n\t\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\n\t\t\t// Create a column\n\t\t\tconst range: any = {}\n\t\t\tuniqueRange.forEach((ran: any) => {\n\t\t\t\t// Initialize matrix to empty state\n\t\t\t\trange[ran] = {\n\t\t\t\t\tvalue: null,\n\t\t\t\t\tindex: -1\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// Complete the matrix by cloning the column to all domains\n\t\t\tuniqueDomain.forEach((dom: any) => {\n\t\t\t\tthis._matrix[dom] = cloneDeep(range)\n\t\t\t})\n\n\t\t\t// Fill in user passed data\n\t\t\tthis.getDisplayData().forEach((d: any, i: number) => {\n\t\t\t\tthis._matrix[d[domainIdentifier]][d[rangeIdentifier]] = {\n\t\t\t\t\tvalue: d['value'],\n\t\t\t\t\tindex: i\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\treturn this._matrix\n\t}\n\n\t/**\n\t * Sets the data for the current instance.\n\t *\n\t * This method sanitizes the provided data, generates data groups,\n\t * and updates the instance's state with the sanitized data and data groups.\n\t * It also resets the `_domains`, `_ranges`, and `_matrix` attributes to their empty states.\n\t *\n\t * @param {any} newData - The new data to be set. This data will be cloned and sanitized.\n\t * @returns {any} - The sanitized version of the provided data.\n\t */\n\tsetData(newData: any) {\n\t\tconst sanitizedData = this.sanitize(cloneDeep(newData))\n\t\tconst dataGroups = this.generateDataGroups(sanitizedData)\n\n\t\tthis.set({\n\t\t\tdata: sanitizedData,\n\t\t\tdataGroups\n\t\t})\n\n\t\t// Set attributes to empty\n\t\tthis._domains = []\n\t\tthis._ranges = []\n\t\tthis._matrix = {}\n\n\t\treturn sanitizedData\n\t}\n\n\t/**\n\t * Converts Object matrix into a single array\n\t * @returns object[]\n\t */\n\tgetMatrixAsArray(): object[] {\n\t\tif (isEmpty(this._matrix)) {\n\t\t\tthis.getMatrix()\n\t\t}\n\n\t\tconst uniqueDomain = this.getUniqueDomain()\n\t\tconst uniqueRange = this.getUniqueRanges()\n\n\t\tconst domainIdentifier = this.services.cartesianScales.getDomainIdentifier()\n\t\tconst rangeIdentifier = this.services.cartesianScales.getRangeIdentifier()\n\n\t\tconst arr: any[] = []\n\t\tuniqueDomain.forEach(domain => {\n\t\t\tuniqueRange.forEach(range => {\n\t\t\t\tconst element: any = {\n\t\t\t\t\tvalue: this._matrix[domain][range].value,\n\t\t\t\t\tindex: this._matrix[domain][range].index\n\t\t\t\t}\n\t\t\t\telement[domainIdentifier] = domain\n\t\t\t\telement[rangeIdentifier] = range\n\t\t\t\tarr.push(element)\n\t\t\t})\n\t\t})\n\n\t\treturn arr\n\t}\n\n\t/**\n\t * Generate tabular data from display data\n\t * @returns Array<Object>\n\t */\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst { primaryDomain, primaryRange } = this.assignRangeAndDomains()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\t\tlet domainValueFormatter: any\n\n\t\tconst headers = [primaryDomain.label, primaryRange.label, 'Value']\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[primaryDomain.identifier] === null\n\t\t\t\t\t? '&ndash;'\n\t\t\t\t\t: domainValueFormatter\n\t\t\t\t\t\t? domainValueFormatter(datum[primaryDomain.identifier])\n\t\t\t\t\t\t: datum[primaryDomain.identifier],\n\n\t\t\t\tdatum[primaryRange.identifier] === null ? '&ndash;' : datum[primaryRange.identifier],\n\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\t// Uses quantize scale to return class names\n\tgetColorClassName(configs: { value?: number; originalClassName?: string }) {\n\t\treturn `${configs.originalClassName} ${this._colorScale(configs.value as number)}`\n\t}\n\n\tprotected setColorClassNames() {\n\t\tconst options = this.getOptions()\n\n\t\tconst customColors = getProperty(options, 'color', 'gradient', 'colors')\n\t\tconst customColorsEnabled = !isEmpty(customColors)\n\n\t\tlet colorPairingOption = getProperty(options, 'color', 'pairing', 'option')\n\n\t\t// If domain consists of negative and positive values, use diverging palettes\n\t\tconst domain = this.getValueDomain()\n\t\tconst colorScheme = domain[0] < 0 && domain[1] > 0 ? 'diverge' : 'mono'\n\n\t\t// Use default color pairing options if not in defined range\n\t\tif (colorPairingOption < 1 && colorPairingOption > 4 && colorScheme === 'mono') {\n\t\t\tcolorPairingOption = 1\n\t\t} else if (colorPairingOption < 1 && colorPairingOption > 2 && colorScheme === 'diverge') {\n\t\t\tcolorPairingOption = 1\n\t\t}\n\n\t\t// Uses css classes for fill\n\t\tconst colorPairing = customColorsEnabled ? customColors : []\n\n\t\tif (!customColorsEnabled) {\n\t\t\t// Add class names to list and the amount based on the color scheme\n\t\t\t// Carbon charts has 11 colors for a single monochromatic palette & 17 for a divergent palette\n\t\t\tconst colorGroupingLength = colorScheme === 'diverge' ? 17 : 11\n\t\t\tfor (let i = 1; i < colorGroupingLength + 1; i++) {\n\t\t\t\tcolorPairing.push(`fill-${colorScheme}-${colorPairingOption}-${i}`)\n\t\t\t}\n\t\t}\n\n\t\t// Save scale type\n\t\tthis._colorScale = scaleQuantize()\n\t\t\t.domain(domain as [number, number])\n\t\t\t.range(colorPairing)\n\t\tconst colorOptions = getProperty(this.getOptions(), 'color')\n\t\tthis._colorScale = getColorScale(this.getDisplayData(), colorOptions)\n\t}\n}\n","// Internal Imports\nimport { ChartModelCartesian } from './cartesian-charts'\nimport { getProperty } from '@/tools'\nimport { get } from 'lodash-es'\n\n/**\n * this is intended for binned type of charts\n * */\nexport class ChartModelBinned extends ChartModelCartesian {\n\tgetTabularDataArray() {\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\t\tconst binnedStackedData = this.getBinnedStackedData()\n\n\t\tconst headers = [\n\t\t\tget(options, 'bins.rangeLabel') || 'Range',\n\t\t\t...binnedStackedData.map(datum => get(datum, `0.${groupMapsTo}`))\n\t\t]\n\t\tconst cells = [\n\t\t\t...get(binnedStackedData, 0).map((d, i) => [\n\t\t\t\t`${numberFormatter(Number(get(d, 'data.x0')), localeCode)} – ${numberFormatter(\n\t\t\t\t\tNumber(get(d, 'data.x1')),\n\t\t\t\t\tlocaleCode\n\t\t\t\t)}`,\n\t\t\t\t...binnedStackedData.map(datum =>\n\t\t\t\t\tnumberFormatter(get(datum[i], `data.${get(datum[i], groupMapsTo)}`), localeCode)\n\t\t\t\t)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModel } from './model'\nimport { ChartTabularData } from '@/interfaces/model'\n\n/** The meter chart model layer which extends some of the data setting options.\n * Meter only uses 1 dataset\n *  */\n\nexport class MeterChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetMaximumDomain(data: any) {\n\t\tconst max = data.reduce((accumulator: number, datum: any) => accumulator + datum.value, 0)\n\t\treturn max\n\t}\n\n\t/**\n\t * Use a provided color for the bar or default to carbon color if no status provided.\n\t * Defaults to carbon color otherwise.\n\t * @param group dataset group label\n\t */\n\tgetFillColor(group: string) {\n\t\tconst options = this.getOptions()\n\t\tconst userProvidedScale = getProperty(options, 'color', 'scale')\n\t\tconst status = this.getStatus()\n\t\t// user provided a fill color or there isn't a status we can use the colorScale\n\t\tif (userProvidedScale || !status) {\n\t\t\treturn super.getFillColor(group)\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/**\n\t * Get the associated status for the data by checking the ranges\n\t */\n\tgetStatus() {\n\t\tconst options = this.getOptions()\n\t\tconst dataValues = getProperty(this.getDisplayData())\n\n\t\tconst totalValue =\n\t\t\tdataValues?.reduce((previous: any, current: any) => {\n\t\t\t\treturn previous + current.value\n\t\t\t}, 0) ?? 0\n\n\t\t// use max value if the percentage is bigger than 100%\n\t\tconst boundedValue = getProperty(options, 'meter', 'proportional')\n\t\t\t? totalValue\n\t\t\t: totalValue > 100\n\t\t\t\t? 100\n\t\t\t\t: totalValue\n\n\t\t// user needs to supply ranges\n\t\tconst allRanges = getProperty(options, 'meter', 'status', 'ranges')\n\n\t\tif (allRanges) {\n\t\t\tconst result = allRanges.filter(\n\t\t\t\t(step: any) => step.range[0] <= boundedValue && boundedValue <= step.range[1]\n\t\t\t)\n\t\t\tif (result.length > 0) {\n\t\t\t\treturn result[0].status\n\t\t\t}\n\t\t}\n\n\t\treturn null\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { groupMapsTo } = options.data\n\t\tconst status = this.getStatus()\n\t\tconst proportional = getProperty(options, 'meter', 'proportional')\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tlet headers = []\n\t\tlet cells: ChartTabularData = []\n\t\tlet domainMax: number\n\t\t// Display the appropriate columns and fields depending on the type of meter\n\t\tif (proportional === null) {\n\t\t\tdomainMax = 100\n\t\t\tconst datum = displayData[0]\n\t\t\theaders = ['Group', 'Value', ...(status ? ['Status'] : [])]\n\t\t\tcells = [\n\t\t\t\t[\n\t\t\t\t\tdatum[groupMapsTo],\n\t\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(datum['value'], localeCode),\n\t\t\t\t\t...(status ? [status] : [])\n\t\t\t\t]\n\t\t\t]\n\t\t} else {\n\t\t\tconst total = getProperty(proportional, 'total')\n\t\t\tdomainMax = total ? total : this.getMaximumDomain(displayData)\n\t\t\theaders = ['Group', 'Value', 'Percentage of total']\n\t\t\tcells = [\n\t\t\t\t...displayData.map((datum: any) => {\n\t\t\t\t\tlet value\n\t\t\t\t\tdatum['value'] !== null && datum['value'] !== undefined\n\t\t\t\t\t\t? (value = Number(datum['value']))\n\t\t\t\t\t\t: (value = 0)\n\t\t\t\t\tconst percentValue = Number(((datum['value'] / domainMax) * 100).toFixed(2))\n\t\t\t\t\treturn [\n\t\t\t\t\t\tdatum[groupMapsTo],\n\t\t\t\t\t\tdatum['value'] === null ? '&ndash;' : numberFormatter(value, localeCode),\n\t\t\t\t\t\tnumberFormatter(percentValue, localeCode) + ' %'\n\t\t\t\t\t]\n\t\t\t\t})\n\t\t\t]\n\t\t}\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModelCartesian } from './cartesian-charts'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class RadarChartModel extends ChartModelCartesian {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst options = this.getOptions()\n\t\tconst groupedData = this.getGroupedData()\n\t\tconst { angle, value } = getProperty(options, 'radar', 'axes')\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(options, 'locale')\n\n\t\tconst additionalHeaders = getProperty(groupedData, '0', 'data').map((d: any) => d[angle])\n\t\tconst headers = ['Group', ...additionalHeaders]\n\t\tconst cells = [\n\t\t\t...groupedData.map(datum => {\n\t\t\t\treturn [\n\t\t\t\t\tdatum['name'],\n\t\t\t\t\t...additionalHeaders.map((_: any, i: number) =>\n\t\t\t\t\t\tgetProperty(datum, 'data', i, value) !== null\n\t\t\t\t\t\t\t? numberFormatter(getProperty(datum, 'data', i, value), localeCode)\n\t\t\t\t\t\t\t: '&ndash;'\n\t\t\t\t\t)\n\t\t\t\t]\n\t\t\t})\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { ChartModel } from './model'\n\n/**\n * The tree chart model layer\n */\nexport class TreeChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\t/**\n\t * Retrieves and formats tabular data from the display data.\n\t *\n\t * @returns {any[]} An object containing the headers and cells of the tabular data.\n\t */\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\n\t\tconst headers = ['Child', 'Parent']\n\t\tconst cells = []\n\t\tdisplayData.forEach((datum: any) => {\n\t\t\t// Call recursive function\n\t\t\tthis.getChildrenDatums(datum, cells)\n\t\t\tcells.push([datum.name, '&ndash;'])\n\t\t})\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n\n\t/**\n\t * Determine the child parent relationship in nested data\n\t * @private\n\t * @param {any} datum - The datum node to process.\n\t * @param {any[]} [result=[]] - An array to accumulate the resulting data.\n\t * @returns {any[]} The accumulated result array.\n\t */\n\tprivate getChildrenDatums(datum: any, result: any[] = []) {\n\t\t// Check to see if datum has children before iterating through it\n\t\tif (datum.children) {\n\t\t\tif (datum.children.length > 0) {\n\t\t\t\tdatum.children.forEach((child: any) => {\n\t\t\t\t\tthis.getChildrenDatums(child, result)\n\t\t\t\t\tresult.push([child.name, datum.name])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModel } from './model'\n\n/**\n * The treemap chart model layer\n */\nexport class TreemapChartModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst { number: numberFormatter, code: localeCode } = getProperty(this.getOptions(), 'locale')\n\n\t\tconst headers = ['Child', 'Group', 'Value']\n\t\tconst cells = []\n\t\tdisplayData.forEach((datum: any) => {\n\t\t\tif (Array.isArray(datum.children)) {\n\t\t\t\tdatum.children.forEach((child: any) => {\n\t\t\t\t\tcells.push([\n\t\t\t\t\t\tchild.name,\n\t\t\t\t\t\tdatum.name,\n\t\t\t\t\t\tchild.value === null ? '&ndash;' : numberFormatter(child.value, localeCode)\n\t\t\t\t\t])\n\t\t\t\t})\n\t\t\t} else if (getProperty(datum.name) !== null && getProperty(datum.value)) {\n\t\t\t\tcells.push(['–', datum.name, numberFormatter(datum.value, localeCode)])\n\t\t\t}\n\t\t})\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n","import { getProperty } from '@/tools'\nimport { ChartModel } from './model'\n\n/** The charting model layer which includes mainly the chart data and options,\n * as well as some misc. information to be shared among components */\nexport class WordCloudModel extends ChartModel {\n\tconstructor(services: any) {\n\t\tsuper(services)\n\t}\n\n\tgetTabularDataArray() {\n\t\tconst displayData = this.getDisplayData()\n\t\tconst options = this.getOptions()\n\t\tconst { fontSizeMapsTo, wordMapsTo } = options.wordCloud\n\t\tconst { groupMapsTo } = options.data\n\t\tconst { code: localeCode, number: numberFormatter } = getProperty(options, 'locale')\n\n\t\tconst headers = [options.tooltip.wordLabel, 'Group', options.tooltip.valueLabel]\n\t\tconst cells = [\n\t\t\t...displayData.map((datum: any) => [\n\t\t\t\tdatum[wordMapsTo],\n\t\t\t\tdatum[groupMapsTo],\n\t\t\t\tnumberFormatter(datum[fontSizeMapsTo], localeCode)\n\t\t\t])\n\t\t]\n\n\t\treturn super.formatTable({ headers, cells })\n\t}\n}\n"],"names":["arrayAggregator","array","setter","iteratee","accumulator","index","length","value","baseAggregator","collection","baseEach","key","createAggregator","initializer","func","isArray","baseIteratee","fromPairs","pairs","result","pair","objectProto","hasOwnProperty","groupBy","baseAssignValue","count","values","valueof","identity","x","compareDefined","compare","ascending","ascendingDefined","a","b","slice","constant","nice","start","stop","prestep","step","tickIncrement","thresholdSturges","bin","domain","extent","threshold","sturges","histogram","data","i","n","xz","x0","x1","tz","max","tn","ticks","m","bins","j","bisect","_","quickselect","k","left","right","z","s","sd","newLeft","newRight","t","swap","quantile","p","numbers","min","i0","value0","value1","none$1","series","order","s0","s1","none","o","stackValue","d","stackSeries","stack","keys","orderNone","offset","offsetNone","sz","oz","stackOffsetDiverging","dy","yp","yn","_sanitizeCsvCell","cellContent","_trimmedCell","ChartModel","services","headers","cells","options","localeCode","dateFormatter","numberFormatter","getProperty","tableHeadingFormatter","tableCellFormatter","cartesianScales","domainScaleType","domainValueFormatter","ScaleTypes","val","groups","allData","dataGroups","groupMapsTo","axesOptions","item","axis","mapsTo","scaleType","datum","end","group","ACTIVE","legendConfigs","dataGroup","newData","sanitizedData","cloneDeep","mainXPos","domainIdentifier","axisOptions","axisBins","histogramConfigs","areBinsDefined","d3Bin","binsWidth","binsDomain","groupsKeys","histogramData","aggregateDataByGroup","dataGroupNames","dataValuesGroupedByKeys","element","displayData","groupedData","groupName","stackKeys","uniq","formatDateTillMilliSeconds","axisPosition","dateA","dateB","binStart","binEnd","correspondingValues","correspondingBin","dataGroupName","binItem","correspondingDatum","rangeIdentifier","percentage","divergent","maxByKey","name","denominator","newState","configs","newConfig","property","newOptions","updateLegendAdditionalItems","merge","animate","Events","changedLabel","DISABLED","hasDeactivatedItems","activeItems","indexToChange","updatedActiveItems","activeItem","defaultFilled","defaultFillColor","defaultStrokeColor","userProvidedScale","colorPairingTag","className","type","tabularData","datasets","labels","dataset","datasetLabel","correspondingLabel","updatedDatum","csvString","row","column","part","fileName","customFilename","uniqueDataGroups","getStatus","colorPairingOptions","numberOfVariants","pairingOption","colorPairingCounts","colorConfigs","numberOfColors","colorPairing","scaleOrdinal","ChartModelCartesian","AxisFlavor","isDualAxes","scales","scale","position","primaryDomain","primaryRange","secondaryDomain","secondaryRange","AxisPositions","definedZoomBarData","newZoomBarData","zoomBarNormalizedValues","allDates","date","sum","keysToCheck","axisPositionKey","axisMapsTo","AlluvialChartModel","BoxplotChartModel","boxplotData","record","q1","q3","iqr","irq1","irq3","outliers","normalValues","minNormalValue","maxNormalValue","BulletChartModel","matchingRangeIndex","range","performanceAreaTitles","ChoroplethModel","isEmpty","country","colorOptions","getColorScale","CirclePackChartModel","zoomOptions","depth","userProvidedDepth","LegendItemType","depthOne","node","child","children","parent","totalSum","grandParent","parentWithinIteration","PieChartModel","valueMapsTo","GaugeChartModel","HeatmapModel","limits","scaleLinear","mainXAxisPosition","customDomain","mainYAxisPosition","uniqueDomain","uniqueRange","ran","dom","arr","customColors","customColorsEnabled","colorPairingOption","colorScheme","colorGroupingLength","scaleQuantize","ChartModelBinned","binnedStackedData","get","MeterChartModel","status","dataValues","totalValue","previous","current","boundedValue","allRanges","proportional","domainMax","total","percentValue","RadarChartModel","angle","additionalHeaders","TreeChartModel","TreemapChartModel","WordCloudModel","fontSizeMapsTo","wordMapsTo"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]}