import { a3 as Lt, aC as Nt, aD as Ct, aE as It, aF as ut, aG as Zt, aH as Ft, aI as zt, a0 as Vt, aJ as Ht, aK as Yt, aL as Xt, aM as Gt, _ as $t, W as Ut, ax as q, aN as Kt, aO as qt, n as j, g as c, F as W, aP as T, aQ as M, aR as E, aS as jt, aT as ft, aU as mt, h as J, ar as Wt, ao as Jt, ad as dt, ai as Qt, H as ti } from "./color-scale-utils-ycwO-Ibq.mjs";
import { z as ii, A as O, e as Q, S as A, D as ei, s as ni, v as si, x as oi, y as ai, u as ri } from "./angle-utils-CQDEbkP4.mjs";
import { $ as w, e as _, i as C, S as m } from "./axis-scales-CPuwbFQf.mjs";
function pt(i) {
  var t = i == null ? 0 : i.length;
  return t ? Lt(i, 1) : [];
}
function hi(i) {
  return Nt(Ct(i, void 0, pt), i + "");
}
function ci(i, t, e) {
  var n = -1, s = i.length;
  t < 0 && (t = -t > s ? 0 : s + t), e = e > s ? s : e, e < 0 && (e += s), s = t > e ? 0 : e - t >>> 0, t >>>= 0;
  for (var o = Array(s); ++n < s; )
    o[n] = i[n + t];
  return o;
}
function li(i, t) {
  return t.length < 2 ? i : It(i, ci(t, 0, -1));
}
function _i(i, t) {
  return t = ut(t, i), i = li(i, t), i == null || delete i[Zt(Ft(t))];
}
function ui(i) {
  return zt(i) ? void 0 : i;
}
var fi = 1, mi = 2, di = 4, pi = hi(function(i, t) {
  var e = {};
  if (i == null)
    return e;
  var n = !1;
  t = Vt(t, function(o) {
    return o = ut(o, i), n || (n = o.length > 1), o;
  }), Ht(i, Yt(i), e), n && (e = Xt(e, fi | mi | di, ui));
  for (var s = t.length; s--; )
    _i(e, t[s]);
  return e;
});
function tt(i) {
  return Math.log(i);
}
function it(i) {
  return Math.exp(i);
}
function xi(i) {
  return -Math.log(-i);
}
function gi(i) {
  return -Math.exp(-i);
}
function yi(i) {
  return isFinite(i) ? +("1e" + i) : i < 0 ? 0 : i;
}
function vi(i) {
  return i === 10 ? yi : i === Math.E ? Math.exp : (t) => Math.pow(i, t);
}
function Ti(i) {
  return i === Math.E ? Math.log : i === 10 && Math.log10 || i === 2 && Math.log2 || (i = Math.log(i), (t) => Math.log(t) / i);
}
function et(i) {
  return (t, e) => -i(-t, e);
}
function Di(i) {
  const t = i(tt, it), e = t.domain;
  let n = 10, s, o;
  function a() {
    return s = Ti(n), o = vi(n), e()[0] < 0 ? (s = et(s), o = et(o), i(xi, gi)) : i(tt, it), t;
  }
  return t.base = function(r) {
    return arguments.length ? (n = +r, a()) : n;
  }, t.domain = function(r) {
    return arguments.length ? (e(r), a()) : e();
  }, t.ticks = (r) => {
    const h = e();
    let l = h[0], f = h[h.length - 1];
    const y = f < l;
    y && ([l, f] = [f, l]);
    let p = s(l), v = s(f), g, d;
    const D = r == null ? 10 : +r;
    let u = [];
    if (!(n % 1) && v - p < D) {
      if (p = Math.floor(p), v = Math.ceil(v), l > 0) {
        for (; p <= v; ++p)
          for (g = 1; g < n; ++g)
            if (d = p < 0 ? g / o(-p) : g * o(p), !(d < l)) {
              if (d > f) break;
              u.push(d);
            }
      } else for (; p <= v; ++p)
        for (g = n - 1; g >= 1; --g)
          if (d = p > 0 ? g / o(-p) : g * o(p), !(d < l)) {
            if (d > f) break;
            u.push(d);
          }
      u.length * 2 < D && (u = q(l, f, D));
    } else
      u = q(p, v, Math.min(v - p, D)).map(o);
    return y ? u.reverse() : u;
  }, t.tickFormat = (r, h) => {
    if (r == null && (r = 10), h == null && (h = n === 10 ? "s" : ","), typeof h != "function" && (!(n % 1) && (h = Kt(h)).precision == null && (h.trim = !0), h = qt(h)), r === 1 / 0) return h;
    const l = Math.max(1, n * r / t.ticks().length);
    return (f) => {
      let y = f / o(Math.round(s(f)));
      return y * n < n - 0.5 && (y *= n), y <= l ? h(f) : "";
    };
  }, t.nice = () => e(ii(e(), {
    floor: (r) => o(Math.floor(s(r))),
    ceil: (r) => o(Math.ceil(s(r)))
  })), t;
}
function xt() {
  const i = Di(Gt()).domain([1, 10]);
  return i.copy = () => $t(i, xt()).base(i.base()), Ut.apply(i, arguments), i;
}
function k(i, t, e) {
  i._context.bezierCurveTo(
    (2 * i._x0 + i._x1) / 3,
    (2 * i._y0 + i._y1) / 3,
    (i._x0 + 2 * i._x1) / 3,
    (i._y0 + 2 * i._y1) / 3,
    (i._x0 + 4 * i._x1 + t) / 6,
    (i._y0 + 4 * i._y1 + e) / 6
  );
}
function L(i) {
  this._context = i;
}
L.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        k(this, this._x1, this._y1);
      // falls through
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, t) : this._context.moveTo(i, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // falls through
      default:
        k(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = i, this._y0 = this._y1, this._y1 = t;
  }
};
function Ai(i) {
  return new L(i);
}
function gt(i) {
  this._context = i;
}
gt.prototype = {
  areaStart: O,
  areaEnd: O,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1, this._x2 = i, this._y2 = t;
        break;
      case 1:
        this._point = 2, this._x3 = i, this._y3 = t;
        break;
      case 2:
        this._point = 3, this._x4 = i, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + i) / 6, (this._y0 + 4 * this._y1 + t) / 6);
        break;
      default:
        k(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = i, this._y0 = this._y1, this._y1 = t;
  }
};
function Oi(i) {
  return new gt(i);
}
function yt(i) {
  this._context = i;
}
yt.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var e = (this._x0 + 4 * this._x1 + i) / 6, n = (this._y0 + 4 * this._y1 + t) / 6;
        this._line ? this._context.lineTo(e, n) : this._context.moveTo(e, n);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        k(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = i, this._y0 = this._y1, this._y1 = t;
  }
};
function Mi(i) {
  return new yt(i);
}
function vt(i, t) {
  this._basis = new L(i), this._beta = t;
}
vt.prototype = {
  lineStart: function() {
    this._x = [], this._y = [], this._basis.lineStart();
  },
  lineEnd: function() {
    var i = this._x, t = this._y, e = i.length - 1;
    if (e > 0)
      for (var n = i[0], s = t[0], o = i[e] - n, a = t[e] - s, r = -1, h; ++r <= e; )
        h = r / e, this._basis.point(
          this._beta * i[r] + (1 - this._beta) * (n + h * o),
          this._beta * t[r] + (1 - this._beta) * (s + h * a)
        );
    this._x = this._y = null, this._basis.lineEnd();
  },
  point: function(i, t) {
    this._x.push(+i), this._y.push(+t);
  }
};
const bi = function i(t) {
  function e(n) {
    return t === 1 ? new L(n) : new vt(n, t);
  }
  return e.beta = function(n) {
    return i(+n);
  }, e;
}(0.85);
function R(i, t, e) {
  i._context.bezierCurveTo(
    i._x1 + i._k * (i._x2 - i._x0),
    i._y1 + i._k * (i._y2 - i._y0),
    i._x2 + i._k * (i._x1 - t),
    i._y2 + i._k * (i._y1 - e),
    i._x2,
    i._y2
  );
}
function z(i, t) {
  this._context = i, this._k = (1 - t) / 6;
}
z.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        R(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, t) : this._context.moveTo(i, t);
        break;
      case 1:
        this._point = 2, this._x1 = i, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        R(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Si = function i(t) {
  function e(n) {
    return new z(n, t);
  }
  return e.tension = function(n) {
    return i(+n);
  }, e;
}(0);
function V(i, t) {
  this._context = i, this._k = (1 - t) / 6;
}
V.prototype = {
  areaStart: O,
  areaEnd: O,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1, this._x3 = i, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = i, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = i, this._y5 = t;
        break;
      default:
        R(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Pi = function i(t) {
  function e(n) {
    return new V(n, t);
  }
  return e.tension = function(n) {
    return i(+n);
  }, e;
}(0);
function H(i, t) {
  this._context = i, this._k = (1 - t) / 6;
}
H.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        R(this, i, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Ei = function i(t) {
  function e(n) {
    return new H(n, t);
  }
  return e.tension = function(n) {
    return i(+n);
  }, e;
}(0);
function Y(i, t, e) {
  var n = i._x1, s = i._y1, o = i._x2, a = i._y2;
  if (i._l01_a > Q) {
    var r = 2 * i._l01_2a + 3 * i._l01_a * i._l12_a + i._l12_2a, h = 3 * i._l01_a * (i._l01_a + i._l12_a);
    n = (n * r - i._x0 * i._l12_2a + i._x2 * i._l01_2a) / h, s = (s * r - i._y0 * i._l12_2a + i._y2 * i._l01_2a) / h;
  }
  if (i._l23_a > Q) {
    var l = 2 * i._l23_2a + 3 * i._l23_a * i._l12_a + i._l12_2a, f = 3 * i._l23_a * (i._l23_a + i._l12_a);
    o = (o * l + i._x1 * i._l23_2a - t * i._l12_2a) / f, a = (a * l + i._y1 * i._l23_2a - e * i._l12_2a) / f;
  }
  i._context.bezierCurveTo(n, s, o, a, i._x2, i._y2);
}
function Tt(i, t) {
  this._context = i, this._alpha = t;
}
Tt.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    if (i = +i, t = +t, this._point) {
      var e = this._x2 - i, n = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, t) : this._context.moveTo(i, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      // falls through
      default:
        Y(this, i, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const wi = function i(t) {
  function e(n) {
    return t ? new Tt(n, t) : new z(n, 0);
  }
  return e.alpha = function(n) {
    return i(+n);
  }, e;
}(0.5);
function Dt(i, t) {
  this._context = i, this._alpha = t;
}
Dt.prototype = {
  areaStart: O,
  areaEnd: O,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(i, t) {
    if (i = +i, t = +t, this._point) {
      var e = this._x2 - i, n = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = i, this._y3 = t;
        break;
      case 1:
        this._point = 2, this._context.moveTo(this._x4 = i, this._y4 = t);
        break;
      case 2:
        this._point = 3, this._x5 = i, this._y5 = t;
        break;
      default:
        Y(this, i, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const ki = function i(t) {
  function e(n) {
    return t ? new Dt(n, t) : new V(n, 0);
  }
  return e.alpha = function(n) {
    return i(+n);
  }, e;
}(0.5);
function At(i, t) {
  this._context = i, this._alpha = t;
}
At.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    if (i = +i, t = +t, this._point) {
      var e = this._x2 - i, n = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(e * e + n * n, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      // falls through
      default:
        Y(this, i, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Ri = function i(t) {
  function e(n) {
    return t ? new At(n, t) : new H(n, 0);
  }
  return e.alpha = function(n) {
    return i(+n);
  }, e;
}(0.5);
function nt(i) {
  return i < 0 ? -1 : 1;
}
function st(i, t, e) {
  var n = i._x1 - i._x0, s = t - i._x1, o = (i._y1 - i._y0) / (n || s < 0 && -0), a = (e - i._y1) / (s || n < 0 && -0), r = (o * s + a * n) / (n + s);
  return (nt(o) + nt(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(r)) || 0;
}
function ot(i, t) {
  var e = i._x1 - i._x0;
  return e ? (3 * (i._y1 - i._y0) / e - t) / 2 : t;
}
function I(i, t, e) {
  var n = i._x0, s = i._y0, o = i._x1, a = i._y1, r = (o - n) / 3;
  i._context.bezierCurveTo(n + r, s + r * t, o - r, a - r * e, o, a);
}
function B(i) {
  this._context = i;
}
B.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        I(this, this._t0, ot(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, t) {
    var e = NaN;
    if (i = +i, t = +t, !(i === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(i, t) : this._context.moveTo(i, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, I(this, ot(this, e = st(this, i, t)), e);
          break;
        default:
          I(this, this._t0, e = st(this, i, t));
          break;
      }
      this._x0 = this._x1, this._x1 = i, this._y0 = this._y1, this._y1 = t, this._t0 = e;
    }
  }
};
function Ot(i) {
  this._context = new Mt(i);
}
(Ot.prototype = Object.create(B.prototype)).point = function(i, t) {
  B.prototype.point.call(this, t, i);
};
function Mt(i) {
  this._context = i;
}
Mt.prototype = {
  moveTo: function(i, t) {
    this._context.moveTo(t, i);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(i, t) {
    this._context.lineTo(t, i);
  },
  bezierCurveTo: function(i, t, e, n, s, o) {
    this._context.bezierCurveTo(t, i, n, e, o, s);
  }
};
function Bi(i) {
  return new B(i);
}
function Li(i) {
  return new Ot(i);
}
function bt(i) {
  this._context = i;
}
bt.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var i = this._x, t = this._y, e = i.length;
    if (e)
      if (this._line ? this._context.lineTo(i[0], t[0]) : this._context.moveTo(i[0], t[0]), e === 2)
        this._context.lineTo(i[1], t[1]);
      else
        for (var n = at(i), s = at(t), o = 0, a = 1; a < e; ++o, ++a)
          this._context.bezierCurveTo(n[0][o], s[0][o], n[1][o], s[1][o], i[a], t[a]);
    (this._line || this._line !== 0 && e === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(i, t) {
    this._x.push(+i), this._y.push(+t);
  }
};
function at(i) {
  var t, e = i.length - 1, n, s = new Array(e), o = new Array(e), a = new Array(e);
  for (s[0] = 0, o[0] = 2, a[0] = i[0] + 2 * i[1], t = 1; t < e - 1; ++t) s[t] = 1, o[t] = 4, a[t] = 4 * i[t] + 2 * i[t + 1];
  for (s[e - 1] = 2, o[e - 1] = 7, a[e - 1] = 8 * i[e - 1] + i[e], t = 1; t < e; ++t) n = s[t] / o[t - 1], o[t] -= n, a[t] -= n * a[t - 1];
  for (s[e - 1] = a[e - 1] / o[e - 1], t = e - 2; t >= 0; --t) s[t] = (a[t] - s[t + 1]) / o[t];
  for (o[e - 1] = (i[e] + s[e - 1]) / 2, t = 0; t < e - 1; ++t) o[t] = 2 * i[t + 1] - s[t + 1];
  return [s, o];
}
function Ni(i) {
  return new bt(i);
}
function N(i, t) {
  this._context = i, this._t = t;
}
N.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(i, t) {
    switch (i = +i, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, t) : this._context.moveTo(i, t);
        break;
      case 1:
        this._point = 2;
      // falls through
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(i, t);
        else {
          var e = this._x * (1 - this._t) + i * this._t;
          this._context.lineTo(e, this._y), this._context.lineTo(e, t);
        }
        break;
      }
    }
    this._x = i, this._y = t;
  }
};
function Ci(i) {
  return new N(i, 0.5);
}
function Ii(i) {
  return new N(i, 0);
}
function Zi(i) {
  return new N(i, 1);
}
class ne extends A {
  /**
   * focal:  object to zoom into
   * canvasElements: all the elements to translate and zoom on the chart area
   * zoomSettings: object containing duration, easing and zoomlevel for the zoom behaviours
   *  */
  zoomIn(t, e, n) {
    let s, o, a;
    const r = n || j;
    t && (s = t.x, o = t.y, a = 2);
    const { width: h, height: l } = ei.getSVGElementSize(this.services.domUtils.getHolder(), {
      useClientDimensions: !0
    });
    e.transition().duration(r.duration).ease(r.ease).attr(
      "transform",
      `translate(${h / 2}, ${l / 2}) scale(${a}) translate(${-s},${-o})`
    ), this.services.events.dispatchEvent(w.CanvasZoom.CANVAS_ZOOM_IN, {
      element: ni(t)
    });
  }
  zoomOut(t, e) {
    const n = e || j;
    t.transition().duration(n.duration).ease(n.ease).attr("transform", ""), this.services.events.dispatchEvent(w.CanvasZoom.CANVAS_ZOOM_OUT);
  }
}
class se extends A {
  init() {
    this.documentFragment = document.createDocumentFragment();
  }
  addEventListener(t, e) {
    this.documentFragment.addEventListener(t, e);
  }
  removeEventListener(t, e) {
    this.documentFragment.removeEventListener(t, e);
  }
  dispatchEvent(t, e) {
    let n;
    e ? n = new CustomEvent(t, {
      detail: e
    }) : (n = document.createEvent("Event"), n.initEvent(t, !1, !0)), this.documentFragment.dispatchEvent(n);
  }
}
class oe extends A {
  constructor(t, e) {
    super(t, e);
  }
  downloadCSV(t, e) {
    const n = document.createElement("a"), s = "text/csv;encoding:utf-8";
    if (navigator.msSaveBlob)
      navigator.msSaveBlob(
        new Blob([t], {
          type: s
        }),
        e
      );
    else if (URL && "download" in n) {
      const o = URL.createObjectURL(
        new Blob([t], {
          type: s
        })
      );
      n.href = o, n.setAttribute("download", e), document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(o);
    } else
      location.href = `data:application/octet-stream,${encodeURIComponent(t)}`;
  }
  downloadImage(t, e) {
    const n = document.createElement("a");
    n.download = e, n.href = t, document.body.appendChild(n), n.click(), document.body.removeChild(n);
  }
}
class ae extends A {
  constructor() {
    super(...arguments), this.pendingTransitions = {};
  }
  init() {
    var t;
    (t = this.services.events) == null || t.addEventListener(w.Model.UPDATE, () => {
      this.pendingTransitions = {};
    });
  }
  setupTransition({ transition: t, name: e, animate: n }) {
    return this.pendingTransitions[t._id] = t, t.on("end interrupt cancel", () => {
      delete this.pendingTransitions[t._id];
    }), this.model.getOptions().animations === !1 || n === !1 ? t.duration(0) : t.duration(
      c(W, e, "duration") || W.default.duration
    );
  }
  getPendingTransitions() {
    return this.pendingTransitions;
  }
}
function S(i, t) {
  const e = +T(i) - +T(t);
  return e < 0 ? -1 : e > 0 ? 1 : e;
}
function Fi(i, t, e) {
  const [n, s] = M(
    e == null ? void 0 : e.in,
    i,
    t
  );
  return n.getFullYear() - s.getFullYear();
}
function zi(i, t, e) {
  const [n, s] = M(
    e == null ? void 0 : e.in,
    i,
    t
  ), o = S(n, s), a = Math.abs(Fi(n, s));
  n.setFullYear(1584), s.setFullYear(1584);
  const r = S(n, s) === -o, h = o * (a - +r);
  return h === 0 ? 0 : h;
}
function X(i, t, e) {
  const n = T(i, e == null ? void 0 : e.in);
  if (isNaN(t)) return E(i, NaN);
  if (!t)
    return n;
  const s = n.getDate(), o = E(i, n.getTime());
  o.setMonth(n.getMonth() + t + 1, 0);
  const a = o.getDate();
  return s >= a ? o : (n.setFullYear(
    o.getFullYear(),
    o.getMonth(),
    s
  ), n);
}
function St(i, t, e) {
  return X(i, t * 12, e);
}
function Vi(i, t, e) {
  return St(i, -t, e);
}
function Hi(i, t, e) {
  const [n, s] = M(
    e == null ? void 0 : e.in,
    i,
    t
  ), o = n.getFullYear() - s.getFullYear(), a = n.getMonth() - s.getMonth();
  return o * 12 + a;
}
function Yi(i, t) {
  const e = T(i, t == null ? void 0 : t.in);
  return e.setHours(23, 59, 59, 999), e;
}
function Xi(i, t) {
  const e = T(i, t == null ? void 0 : t.in), n = e.getMonth();
  return e.setFullYear(e.getFullYear(), n + 1, 0), e.setHours(23, 59, 59, 999), e;
}
function Gi(i, t) {
  const e = T(i, t == null ? void 0 : t.in);
  return +Yi(e, t) == +Xi(e, t);
}
function $i(i, t, e) {
  const [n, s, o] = M(
    e == null ? void 0 : e.in,
    i,
    i,
    t
  ), a = S(s, o), r = Math.abs(
    Hi(s, o)
  );
  if (r < 1) return 0;
  s.getMonth() === 1 && s.getDate() > 27 && s.setDate(30), s.setMonth(s.getMonth() - a * r);
  let h = S(s, o) === -a;
  Gi(n) && r === 1 && S(n, o) === 1 && (h = !1);
  const l = a * (r - +h);
  return l === 0 ? 0 : l;
}
function Ui(i, t, e) {
  return X(i, -t, e);
}
function Ki(i, t, e) {
  const [n, s] = M(
    e == null ? void 0 : e.in,
    i,
    t
  ), o = rt(n, s), a = Math.abs(
    jt(n, s)
  );
  n.setDate(n.getDate() - o * a);
  const r = +(rt(n, s) === -o), h = o * (a - r);
  return h === 0 ? 0 : h;
}
function rt(i, t) {
  const e = i.getFullYear() - t.getFullYear() || i.getMonth() - t.getMonth() || i.getDate() - t.getDate() || i.getHours() - t.getHours() || i.getMinutes() - t.getMinutes() || i.getSeconds() - t.getSeconds() || i.getMilliseconds() - t.getMilliseconds();
  return e < 0 ? -1 : e > 0 ? 1 : e;
}
function Pt(i, t, e) {
  const n = T(i, e == null ? void 0 : e.in);
  return isNaN(t) ? E(i, NaN) : (t && n.setDate(n.getDate() + t), n);
}
function qi(i, t, e) {
  return Pt(i, -t, e);
}
function G(i) {
  return (t) => {
    const n = (i ? Math[i] : Math.trunc)(t);
    return n === 0 ? 0 : n;
  };
}
function ji(i, t, e) {
  const [n, s] = M(
    e == null ? void 0 : e.in,
    i,
    t
  ), o = (+n - +s) / ft;
  return G(e == null ? void 0 : e.roundingMethod)(o);
}
function Et(i, t, e) {
  return E(i, +T(i) + t);
}
function wt(i, t, e) {
  return Et(i, t * ft);
}
function Wi(i, t, e) {
  return wt(i, -t);
}
function kt(i, t) {
  return +T(i) - +T(t);
}
function ht(i, t, e) {
  const n = kt(i, t) / mt;
  return G(e == null ? void 0 : e.roundingMethod)(n);
}
function Z(i, t, e) {
  const n = T(i, e == null ? void 0 : e.in);
  return n.setTime(n.getTime() + t * mt), n;
}
function ct(i, t, e) {
  return Z(i, -t, e);
}
function lt(i, t, e) {
  const n = kt(i, t) / 1e3;
  return G(e == null ? void 0 : e.roundingMethod)(n);
}
function F(i, t, e) {
  return Et(i, t * 1e3);
}
function _t(i, t, e) {
  return F(i, -t);
}
class re extends A {
  constructor() {
    super(...arguments), this.scaleTypes = {
      top: null,
      right: null,
      bottom: null,
      left: null
    }, this.scales = {
      // null or function
      top: null,
      right: null,
      bottom: null,
      left: null
    };
  }
  getDomainAxisPosition({ datum: t = null } = {}) {
    if (this.dualAxes && t) {
      const e = this.model.getOptions(), { groupMapsTo: n } = e.data, s = c(e, "axes", this.secondaryDomainAxisPosition), o = t[n];
      if (s != null && s.correspondingDatasets && s.correspondingDatasets.includes(o))
        return this.secondaryDomainAxisPosition;
    }
    return this.domainAxisPosition;
  }
  getRangeAxisPosition({ datum: t = null, groups: e = null } = {}) {
    if (this.dualAxes) {
      const n = this.model.getOptions(), { groupMapsTo: s } = n.data, o = c(n, "axes", this.secondaryRangeAxisPosition);
      let a;
      if (t !== null ? a = t[s] : e && e.length > 0 && (a = e[0]), o != null && o.correspondingDatasets && o.correspondingDatasets.includes(a))
        return this.secondaryRangeAxisPosition;
    }
    return this.rangeAxisPosition;
  }
  getAxisOptions(t) {
    return c(this.model.getOptions(), "axes", t);
  }
  getDomainAxisOptions() {
    const t = this.getDomainAxisPosition();
    return this.getAxisOptions(t);
  }
  getRangeAxisOptions() {
    const t = this.getRangeAxisPosition();
    return this.getAxisOptions(t);
  }
  getScaleLabel(t) {
    const n = this.getAxisOptions(t).title;
    return n || (t === _.BOTTOM || t === _.TOP ? "x-value" : "y-value");
  }
  getDomainLabel() {
    return this.getScaleLabel(this.getDomainAxisPosition());
  }
  getRangeLabel() {
    return this.getScaleLabel(this.getRangeAxisPosition());
  }
  update() {
    this.determineAxisDuality(), this.findDomainAndRangeAxes(), this.determineOrientation(), Object.keys(_).map(
      (e) => _[e]
    ).forEach((e) => {
      this.scales[e] = this.createScale(e);
    });
  }
  findDomainAndRangeAxes() {
    const t = this.findVerticalAxesPositions(), e = this.findHorizontalAxesPositions(), n = this.findDomainAndRangeAxesPositions(
      t,
      e
    );
    this.domainAxisPosition = n.primaryDomainAxisPosition, this.rangeAxisPosition = n.primaryRangeAxisPosition, this.isDualAxes() && (this.secondaryDomainAxisPosition = n.secondaryDomainAxisPosition, this.secondaryRangeAxisPosition = n.secondaryRangeAxisPosition);
  }
  determineOrientation() {
    (this.rangeAxisPosition === _.LEFT || this.rangeAxisPosition === _.RIGHT) && (this.domainAxisPosition === _.BOTTOM || this.domainAxisPosition === _.TOP) ? this.orientation = C.VERTICAL : this.orientation = C.HORIZONTAL;
  }
  isDualAxes() {
    return this.dualAxes;
  }
  // if any of the axes objects have correspondingDatasets [] asserted we flag the chart as dual axes
  // it does not count as dual axes if it just has another axis turned on but is not actually using it to map a dataset
  determineAxisDuality() {
    var n, s, o, a;
    const t = this.model.getOptions(), e = c(t, "axes");
    ((n = e[_.LEFT]) != null && n.correspondingDatasets && e[_.RIGHT] || (s = e[_.RIGHT]) != null && s.correspondingDatasets && e[_.LEFT] || (o = e[_.TOP]) != null && o.correspondingDatasets && e[_.BOTTOM] || (a = e[_.BOTTOM]) != null && a.correspondingDatasets && e[_.TOP]) && (this.dualAxes = !0);
  }
  getCustomDomainValuesByposition(t) {
    const e = c(this.model.getOptions(), "axes", t, "domain");
    if (e && !Array.isArray(e))
      throw new Error(`Domain in ${t} axis is not a valid array`);
    if (Array.isArray(e) && (this.scaleTypes[t] === m.LINEAR || this.scaleTypes[t] === m.TIME) && e.length !== 2)
      throw new Error(
        `There can only be 2 elements in domain for scale type: ${this.scaleTypes[t]}`
      );
    return e;
  }
  getOrientation() {
    return this.orientation;
  }
  getScaleByPosition(t) {
    return this.scales[t];
  }
  getScaleTypeByPosition(t) {
    return this.scaleTypes[t];
  }
  getDomainAxisScaleType() {
    const t = this.getDomainAxisPosition();
    return this.getScaleTypeByPosition(t);
  }
  getRangeAxisScaleType() {
    const t = this.getRangeAxisPosition();
    return this.getScaleTypeByPosition(t);
  }
  getDomainScale() {
    return this.scales[this.domainAxisPosition];
  }
  getRangeScale() {
    return this.scales[this.rangeAxisPosition];
  }
  // Find the main x-axis out of the 2 x-axis on the chart (when 2D axis is used)
  getMainXAxisPosition() {
    const t = [_.BOTTOM, _.TOP];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (e) => t.indexOf(e) > -1
    );
  }
  // Find the main y-axis out of the 2 y-axis on the chart (when 2D axis is used)
  getMainYAxisPosition() {
    const t = [_.LEFT, _.RIGHT];
    return [this.domainAxisPosition, this.rangeAxisPosition].find(
      (e) => t.indexOf(e) > -1
    );
  }
  getMainXScale() {
    return this.scales[this.getMainXAxisPosition()];
  }
  getMainYScale() {
    return this.scales[this.getMainYAxisPosition()];
  }
  getValueFromScale(t, e, n, s) {
    const o = this.model.getOptions(), r = c(o, "axes")[n], { mapsTo: h } = r, l = c(s, h) !== null ? s[h] : s;
    let f;
    switch (e) {
      case m.LABELS:
        f = t(l) + t.step() / 2;
        break;
      case m.TIME:
        f = t(new Date(l));
        break;
      default:
        f = t(l);
    }
    return f;
  }
  getBoundedScaledValues(t) {
    const { bounds: e } = this.model.getOptions(), n = this.getRangeAxisPosition({ datum: t }), s = this.scales[n], o = this.model.getOptions(), r = c(o, "axes")[n], { mapsTo: h } = r, l = t[h] !== void 0 ? t[h] : t;
    return [
      s(
        c(t, e.upperBoundMapsTo) !== null ? t[e.upperBoundMapsTo] : l
      ),
      s(
        c(t, e.lowerBoundMapsTo) !== null ? t[e.lowerBoundMapsTo] : l
      )
    ];
  }
  getValueThroughAxisPosition(t, e) {
    const n = this.scaleTypes[t], s = this.scales[t];
    return this.getValueFromScale(s, n, t, e);
  }
  getDomainValue(t) {
    const e = this.getDomainAxisPosition({ datum: t });
    return this.getValueThroughAxisPosition(e, t);
  }
  getRangeValue(t) {
    const e = this.getRangeAxisPosition({ datum: t });
    return this.getValueThroughAxisPosition(e, t);
  }
  getMainXScaleType() {
    return this.getScaleTypeByPosition(this.getMainXAxisPosition());
  }
  getMainYScaleType() {
    return this.getScaleTypeByPosition(this.getMainYAxisPosition());
  }
  getDomainIdentifier(t) {
    const e = this.model.getOptions();
    return c(e, "axes", this.getDomainAxisPosition({ datum: t }), "mapsTo");
  }
  getRangeIdentifier(t) {
    const e = this.model.getOptions();
    return c(e, "axes", this.getRangeAxisPosition({ datum: t }), "mapsTo");
  }
  extendsDomain(t, e) {
    const n = this.model.getOptions(), s = c(n, "axes", t);
    if (s.scaleType === m.TIME) {
      const o = c(n, "timeScale", "addSpaceOnEdges");
      return Ji(e, o);
    } else
      return Qi(e, J.paddingRatio, s.scaleType);
  }
  findVerticalAxesPositions() {
    const t = this.model.getOptions(), e = c(t, "axes"), n = this.isDualAxes();
    return c(e, _.LEFT) === null && c(e, _.RIGHT) !== null || c(e, _.RIGHT, "main") === !0 || n && c(e, _.LEFT, "correspondingDatasets") ? {
      primary: _.RIGHT,
      secondary: _.LEFT
    } : { primary: _.LEFT, secondary: _.RIGHT };
  }
  findHorizontalAxesPositions() {
    const t = this.model.getOptions(), e = c(t, "axes"), n = this.isDualAxes();
    return c(e, _.BOTTOM) === null && c(e, _.TOP) !== null || c(e, _.TOP, "main") === !0 || n && c(e, _.BOTTOM, "correspondingDatasets") ? {
      primary: _.TOP,
      secondary: _.BOTTOM
    } : { primary: _.BOTTOM, secondary: _.TOP };
  }
  findDomainAndRangeAxesPositions(t, e) {
    const n = this.model.getOptions(), s = c(n, "axes", t.primary), o = c(n, "axes", e.primary), a = s.scaleType || m.LINEAR, r = o.scaleType || m.LINEAR, h = {
      primaryDomainAxisPosition: null,
      secondaryDomainAxisPosition: null,
      primaryRangeAxisPosition: null,
      secondaryRangeAxisPosition: null
    };
    return h.primaryDomainAxisPosition = e.primary, h.primaryRangeAxisPosition = t.primary, h.secondaryDomainAxisPosition = e.secondary, h.secondaryRangeAxisPosition = t.secondary, (!(r === m.LABELS || r === m.TIME) && a === m.LABELS || a === m.TIME) && (h.primaryDomainAxisPosition = t.primary, h.primaryRangeAxisPosition = e.primary, h.secondaryDomainAxisPosition = t.secondary, h.secondaryRangeAxisPosition = e.secondary), h;
  }
  getScaleDomain(t) {
    const e = this.model.getOptions(), n = c(e, "axes", t), s = c(e, "bounds"), { includeZero: o } = n, a = c(n, "scaleType") || m.LINEAR;
    if (this.model.isDataEmpty())
      return [];
    if (n.binned) {
      const { bins: u } = this.model.getBinConfigurations();
      return [0, Wt(u, (x) => x.length)];
    } else if (n.limitDomainToBins) {
      const { bins: u } = this.model.getBinConfigurations(), x = this.model.getStackKeys({ bins: u });
      return [x[0].split(":")[0], x[x.length - 1].split(":")[1]];
    }
    const r = this.model.getDisplayData(), { extendLinearDomainBy: h, mapsTo: l, percentage: f, thresholds: y } = n, { reference: p, compareTo: v } = J.ratio;
    if (n.domain)
      return a === m.LABELS ? n.domain : (a === m.TIME && (n.domain = n.domain.map(
        (u) => u.getTime === void 0 ? new Date(u) : u
      )), this.extendsDomain(t, n.domain));
    if (f)
      return [0, 100];
    if (n && a === m.LABELS)
      return Jt(r.map((u) => u[l]));
    let g, d;
    const D = this.model.getDataGroupNames();
    if (a === m.LABELS_RATIO)
      return r.map((u) => `${u[p]}/${u[v]}`);
    if (a === m.TIME)
      d = r.map((u) => +new Date(u[l]));
    else if (s && e.axes)
      d = [], r.forEach((u) => {
        d.push(u[l]), u[s.upperBoundMapsTo] && d.push(u[s.upperBoundMapsTo]), u[s.lowerBoundMapsTo] && d.push(u[s.lowerBoundMapsTo]);
      });
    else if (n.stacked === !0 && D && t === this.getRangeAxisPosition()) {
      const { groupMapsTo: u } = e.data, x = this.model.getDataValuesGroupedByKeys({
        groups: D
      }), Rt = r.filter(
        (b) => !D.includes(b[u])
      ), $ = [];
      x.forEach((b) => {
        const { ...Bt } = b;
        let U = 0, K = 0;
        Object.values(pi(Bt, "sharedStackKey")).forEach((P) => {
          isNaN(P) || (P < 0 ? K += P : U += P);
        }), $.push([K, U]);
      }), d = [
        ...pt($),
        ...Rt.map((b) => b[l])
      ];
    } else
      d = [], r.forEach((u) => {
        const x = u[l];
        Array.isArray(x) && x.length === 2 ? (d.push(x[0]), d.push(x[1])) : (h && d.push(Math.max(u[l], u[h])), d.push(x));
      });
    return a !== m.TIME && a !== m.LOG && o && d.push(0), y && y.length > 0 && y.forEach((u) => {
      const x = c(u, "value");
      x !== null && d.push(x);
    }), g = dt(d), g = this.extendsDomain(t, g), g;
  }
  createScale(t) {
    const e = this.model.getOptions(), n = c(e, "axes", t);
    if (!n)
      return null;
    const s = c(n, "scaleType") || m.LINEAR;
    this.scaleTypes[t] = s;
    let o;
    return s === m.TIME ? o = si() : s === m.LOG ? o = xt().base(n.base || 10) : s === m.LABELS || s === m.LABELS_RATIO ? o = oi() : o = Qt(), o.domain(this.getScaleDomain(t)), o;
  }
  getDomainLowerBound(t) {
    let e, n = 0;
    return this.getOrientation() === C.VERTICAL ? e = this.getMainYScale().domain() : e = this.getMainXScale().domain(), c(this.model.getOptions(), "axes", t, "includeZero") === !1 && e[0] > 0 && e[1] > 0 && (n = e[0]), n;
  }
  getHighestDomainThreshold() {
    const t = c(this.model.getOptions(), "axes"), e = this.getDomainAxisPosition(), { thresholds: n } = t[e];
    if (!Array.isArray(n) || Array.isArray(n) && !n.length)
      return null;
    const s = this.getDomainScale(), o = n.sort((r, h) => h.value - r.value)[0];
    return this.getScaleTypeByPosition(e) === m.TIME && (typeof o.value == "string" || o.value.getTime === void 0) && (o.value = new Date(o.value)), {
      threshold: o,
      scaleValue: s(o.value)
    };
  }
  getHighestRangeThreshold() {
    const t = c(this.model.getOptions(), "axes"), e = this.getRangeAxisPosition(), { thresholds: n } = t[e];
    if (!Array.isArray(n) || Array.isArray(n) && !n.length)
      return null;
    const s = this.getRangeScale(), o = n.sort((a, r) => r.value - a.value)[0];
    return {
      threshold: o,
      scaleValue: s(o.value)
    };
  }
}
function Ji(i, t) {
  const e = new Date(i[0]), n = new Date(i[1]);
  return zi(n, e) > 1 ? [Vi(e, t), St(n, t)] : $i(n, e) > 1 ? [Ui(e, t), X(n, t)] : Ki(n, e) > 1 ? [qi(e, t), Pt(n, t)] : ji(n, e) > 1 ? [Wi(e, t), wt(n, t)] : ht(n, e) > 30 ? [
    ct(e, t * 30),
    Z(n, t * 30)
  ] : ht(n, e) > 1 ? [ct(e, t), Z(n, t)] : lt(n, e) > 15 ? [
    _t(e, t * 15),
    F(n, t * 15)
  ] : lt(n, e) > 1 ? [_t(e, t), F(n, t)] : [e, n];
}
function Qi([i, t], e, n) {
  const o = (t - i) * e, a = t <= 0 && t + o > 0 ? 0 : t + o;
  let r = i >= 0 && i - o < 0 ? 0 : i - o;
  if (n === m.LOG && r <= 0) {
    if (i <= 0)
      throw Error("Data must have values greater than 0 if log scale type is used.");
    r = i;
  }
  return [r, a];
}
class he extends A {
  constructor() {
    super(...arguments), this.curveTypes = {
      curveLinear: ri,
      curveLinearClosed: ai,
      curveBasis: Ai,
      curveBasisClosed: Oi,
      curveBasisOpen: Mi,
      curveBundle: bi,
      curveCardinal: Si,
      curveCardinalClosed: Pi,
      curveCardinalOpen: Ei,
      curveCatmullRom: wi,
      curveCatmullRomClosed: ki,
      curveCatmullRomOpen: Ri,
      curveMonotoneX: Bi,
      curveMonotoneY: Li,
      curveNatural: Ni,
      curveStep: Ci,
      curveStepAfter: Zi,
      curveStepBefore: Ii
    };
  }
  getD3Curve() {
    let t = "curveLinear";
    const e = this.model.getOptions().curve;
    if (e && (typeof e == "string" ? t = e : t = e.name), this.curveTypes[t]) {
      let n = this.curveTypes[t];
      return e && Object.keys(e).forEach((s) => {
        n[s] && (n = n[s](e[s]));
      }), n;
    }
    return console.warn(`The curve type '${t}' is invalid, using 'curveLinear' instead`), this.curveTypes.curveLinear;
  }
}
class ce extends A {
  isZoomBarEnabled() {
    if (!this.services.cartesianScales || !c(this.model.getOptions(), "zoomBar", "top", "enabled"))
      return !1;
    this.services.cartesianScales.findDomainAndRangeAxes();
    const t = this.services.cartesianScales.getMainXAxisPosition(), e = c(
      this.model.getOptions(),
      "axes",
      t,
      "scaleType"
    );
    return t === _.BOTTOM && e === m.TIME;
  }
  // get display data for zoom bar
  // basically it's sum of value grouped by time
  getZoomBarData() {
    const t = this.model.getZoomBarData();
    return t && t.length > 1 ? t : this.model.getDisplayData();
  }
  getDefaultZoomBarDomain(t) {
    if (!this.services.zoom) throw new Error("Services zoom not defined");
    const e = t || this.services.zoom.getZoomBarData(), { cartesianScales: n } = this.services;
    if (!n) throw new Error("Services cartesianScales undefined");
    const s = n.getMainXAxisPosition(), o = n.getDomainIdentifier(), a = c(this.model.getOptions(), "axes", s, "domain");
    if (Array.isArray(a) && a.length === 2)
      return a;
    if (!s) throw new Error("Not defined: mainXAxisPosition");
    return n.extendsDomain(
      s,
      dt(e, (r) => r[o])
    );
  }
  handleDomainChange(t, e = { dispatchEvent: !0 }) {
    var n;
    this.model.set({ zoomDomain: t }, { animate: !1 }), e.dispatchEvent && ((n = this.services.events) == null || n.dispatchEvent(w.ZoomDomain.CHANGE, {
      newDomain: t
    }));
  }
  getZoomRatio() {
    return c(this.model.getOptions(), "zoomBar", "zoomRatio");
  }
  // filter out data not inside zoom domain
  // to get better range value for axis label
  filterDataForRangeAxis(t, e) {
    var a;
    const n = this.model.get("zoomDomain"), s = Object.assign(
      { stacked: !1 },
      // default configs
      e
    ), o = c(this.model.getOptions(), "zoomBar", "updateRangeAxis");
    if (this.isZoomBarEnabled() && o && n) {
      const r = s.stacked ? "sharedStackKey" : (a = this.services.cartesianScales) == null ? void 0 : a.getDomainIdentifier(), h = t.filter(
        (l) => new Date(l[r]) >= n[0] && new Date(l[r]) <= n[1]
      );
      if (h.length > 0)
        return h;
    }
    return t;
  }
  zoomIn(t = this.getZoomRatio()) {
    var v;
    const e = this.model.get("zoomDomain"), n = ti.handleWidth, s = (v = this.services.cartesianScales) == null ? void 0 : v.getMainXScale().copy();
    s.domain(this.getDefaultZoomBarDomain());
    const o = s(e[0]), a = s(e[1]);
    if (a - o < n + 1)
      return;
    const r = s.range(), h = a - o, l = Math.min((r[1] - r[0]) / 2 * (t / 2), h / 2);
    let f = o + l, y = a - l;
    f >= y && (f = o + h / 2 - n / 2, y = a - h / 2 + n / 2);
    const p = [s.invert(f), s.invert(y)];
    (e[0].valueOf() !== p[0].valueOf() || e[1].valueOf() !== p[1].valueOf()) && this.handleDomainChange(p);
  }
  zoomOut(t = this.getZoomRatio()) {
    const e = this.model.get("zoomDomain");
    if (!this.services.cartesianScales) throw new Error("Services cartesianScales undefined");
    const n = this.services.cartesianScales.getMainXScale().copy();
    n.domain(this.getDefaultZoomBarDomain());
    const s = n(e[0]), o = n(e[1]), a = n.range(), r = (a[1] - a[0]) / 2 * (t / 2), h = Math.max(s - r, a[0]), l = Math.min(o + r, a[1]), f = [n.invert(h), n.invert(l)];
    (e[0].valueOf() !== f[0].valueOf() || e[1].valueOf() !== f[1].valueOf()) && this.handleDomainChange(f);
  }
  resetZoomDomain() {
    const t = this.model.get("zoomDomain"), e = this.getDefaultZoomBarDomain();
    (t[0].valueOf() !== e[0].valueOf() || t[1].valueOf() !== e[1].valueOf()) && this.handleDomainChange(e);
  }
  // check if current zoom domain is already the min zoom domain
  // when toolbar is rendered, we don't render chart yet
  // don't depend on scale range
  isMinZoomDomain() {
    const t = this.model.get("zoomDomain"), e = this.getDefaultZoomBarDomain();
    if (!t || !e)
      return !1;
    const n = t[1].valueOf() - t[0].valueOf(), s = e[1].valueOf() - e[0].valueOf(), o = c(this.model.getOptions(), "zoomBar", "minZoomRatio");
    return n / s < o;
  }
  // check if current zoom domain is already the max zoom domain
  isMaxZoomDomain() {
    const t = this.model.get("zoomDomain"), e = this.getDefaultZoomBarDomain();
    return !!(t && e && t[0].valueOf() === e[0].valueOf() && t[1].valueOf() === e[1].valueOf());
  }
  isEmptyState() {
    return this.getZoomBarData().length === 0;
  }
  isZoomBarLoading(t) {
    return c(this.model.getOptions(), "zoomBar", t, "loading");
  }
  isZoomBarLocked(t) {
    return c(this.model.getOptions(), "zoomBar", t, "locked");
  }
}
export {
  ne as C,
  se as E,
  oe as F,
  ae as T,
  ce as Z,
  he as a,
  ci as b,
  re as c,
  pt as f
};
//# sourceMappingURL=index-Dc1X-hk8.mjs.map
